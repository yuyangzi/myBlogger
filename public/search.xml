<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WEB应用内容安全策略(Content Security Policy)</title>
      <link href="/2019/02/20/HTPP%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5(Content%20Security%20Policy)/"/>
      <url>/2019/02/20/HTPP%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5(Content%20Security%20Policy)/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB应用内容安全策略-Content-Security-Policy"><a href="#WEB应用内容安全策略-Content-Security-Policy" class="headerlink" title="WEB应用内容安全策略(Content Security Policy)"></a>WEB应用内容安全策略(Content Security Policy)</h1><h2 id="内容安全策略-Content-Security-Policy-是什么"><a href="#内容安全策略-Content-Security-Policy-是什么" class="headerlink" title="内容安全策略(Content Security Policy)是什么?"></a>内容安全策略(Content Security Policy)是什么?</h2><p>&emsp;&emsp;<a href="https://www.w3.org/TR/CSP2/" target="_blank" rel="noopener">内容安全策略(Content Security Policy)</a>简称<code>CSP</code>是由<a href="https://www.w3.org/" target="_blank" rel="noopener">W3C</a>小组定义的一项规范,其主要作用是提供一个额外的安全层,用于检测并削弱某些特定类型的攻击,包括跨站脚本 (XSS) 和数据注入攻击等.</p><p>&emsp;&emsp;目前内容安全策略(Content Security Policy)的规范一共有三个版本:</p><ol><li><a href="https://www.w3.org/TR/CSP1/" target="_blank" rel="noopener">Content Security Policy Level 1</a></li><li><a href="https://www.w3.org/TR/CSP2/" target="_blank" rel="noopener">Content Security Policy Level 2</a></li><li><a href="https://www.w3.org/TR/CSP3/" target="_blank" rel="noopener">Content Security Policy Level 3</a></li></ol><p>&emsp;&emsp;现在主要使用的是第二个版本,第三个版本目前还在草案当中</p><h2 id="CSP的作用"><a href="#CSP的作用" class="headerlink" title="CSP的作用"></a>CSP的作用</h2><p>&emsp;&emsp;<code>CSP</code>被设计出来的目的就是为了<strong>效防范内容注入攻击</strong>,如XSS攻击等.</p><p>&emsp;&emsp;它通过让开发者对自己WEB应用声明一个外部资源加载的白名单,使得客户端在运行WEB应用时对外部资源的加载做出筛选和识别,只加载被允许的网站资源.对于不被允许的网站资源不予加载和执行.同时,还可以将WEB应用中出现的不被允许的资源链接和详情报告给我们指定的网址.如此,大大增强了WEB应用的安全性.使得攻击者即使发现了漏洞,也没法注入脚本,除非还控制了一台列入了白名单的服务器.</p><h2 id="使用CSP"><a href="#使用CSP" class="headerlink" title="使用CSP"></a>使用CSP</h2><h3 id="CSP的选择"><a href="#CSP的选择" class="headerlink" title="CSP的选择"></a>CSP的选择</h3><p>&emsp;&emsp;根据W3C的设计,<code>CSP</code>分为两种模式:</p><ul><li>一种是<code>Content-Security-Policy</code>.</li></ul><p>使用这种模式,将会直接阻止非法的外部资源加载,同时也可以选择是否配置将非法资源加载的链接和行为报告给我们指定的网址</p><ul><li>另一种是<code>Content-Security-Policy-Report-Only</code></li></ul><p>使用这种模式时,客户端在遇到非法的外部资源加载时并不会阻止,而是正常加载.但是会将次加载行为和链接报告给我我指定的网址.所以使用此模式时,必须要使用<code>report-uri</code>策略配置报告非法资源加载情况的网址.</p><p>&emsp;&emsp;以上是<code>CSP</code>策略的两种模式,在实际使用中,我们可以根据自己的情况任意选择其中一种模式.</p><h3 id="CSP的使用方式"><a href="#CSP的使用方式" class="headerlink" title="CSP的使用方式"></a>CSP的使用方式</h3><p>&emsp;&emsp;<code>CSP</code>的使用方式有两种:</p><ul><li>一种是前端开发时直接在HTML页面中使用<code>&lt;meta&gt;</code>标签,如下:</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self';"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- or --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-security-policy-report-only"</span> <span class="attr">content</span>=<span class="string">"default-src 'self';"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>一种是后端开发或服务运维人员对页面的HTTP请求的响应配置<code>Content-Security-Policy</code>属性,如在NGINX服务器上配置如下</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">add_header</span>  Content-Security-Policy  <span class="string">"default-src 'self'"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">add_header</span>  Content-Security-Policy-Report-Only  <span class="string">"default-src 'self'"</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过以上两种方式的任意一种即可启用<code>CSP</code>.</p><h3 id="CSP的配置"><a href="#CSP的配置" class="headerlink" title="CSP的配置"></a>CSP的配置</h3><blockquote><p>&emsp;&emsp;一个策略由一系列策略指令所组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略。你的策略应当包含一个<code>default-src</code>策略指令，在其他资源类型没有符合自己的策略时应用该策略(有关完整列表查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid/default-src" target="_blank" rel="noopener">default-src</a>)。一个策略可以包含<code>default-src</code>或者<code>script-src</code>指令来防止内联脚本运行, 并杜绝<code>eval()</code>的使用。 一个策略也可包含一个<code>default-src</code>或 <code>style-src</code>指令去限制来自一个<code>&lt;style&gt;</code>元素或者style属性的內联样式。</p></blockquote><p>&emsp;&emsp;<strong>示例: 常见用例,来自<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">MDN</a>:</strong></p><ol><li>一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self'</span><br></pre></td></tr></table></figure><ol start="2"><li>一个网站管理者允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self' *.trusted.com</span><br></pre></td></tr></table></figure><ol start="3"><li>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码.</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里，各种内容默认仅允许从文档所在的源获取, 但存在如下例外:</p><blockquote><ul><li>图片可以从任何地方加载(注意 “*” 通配符)。</li><li>多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)。</li><li>可运行脚本仅允许来自于 userscripts.example.com。</li></ul></blockquote><ol start="4"><li>一个线上银行网站的管理者想要确保网站的所有内容都要通过SSL方式获取，以避免攻击者窃听用户发出的请求。</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src https://onlinebanking.jumbobank.com</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该服务器仅允许通过HTTPS方式并仅从onlinebanking.jumbobank.com域名来访问文档。</p><ol start="5"><li>一个在线邮箱的管理者想要允许在邮件里包含HTML，同样图片允许从任何地方加载，但不允许JavaScript或者其他潜在的危险内容(从任意位置加载)。</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self' *.mailsite.com; img-src *</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意这个示例并未指定<code>script-src</code>。在此CSP示例中，站点通过<code>default-src</code>指令的对其进行配置，这也同样意味着脚本文件仅允许从原始服务器获取</p><ol start="6"><li>违例报告样本</li></ol><p>&emsp;&emsp;默认情况下，违规报告并不会发送。为启用发送违规报告，你需要指定<code>report-uri</code>策略指令，并提供至少一个URI地址去递交报告。这个地址可以是相对于当前网站的相对地址，也可以是一个绝对地址：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'none'; style-src cdn.example.com; report-uri /_/csp-reports</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;报告格式如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"csp-report"</span>: &#123;</span><br><span class="line">    <span class="attr">"document-uri"</span>: <span class="string">"http://example.com/signup.html"</span>,</span><br><span class="line">    <span class="attr">"referrer"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"blocked-uri"</span>: <span class="string">"http://example.com/css/style.css"</span>,</span><br><span class="line">    <span class="attr">"violated-directive"</span>: <span class="string">"style-src cdn.example.com"</span>,</span><br><span class="line">    <span class="attr">"original-policy"</span>: <span class="string">"default-src 'none'; style-src cdn.example.com; report-uri /_/csp-reports"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;违例报告的语法:</p><blockquote><p>作为报告的JSON对象报告包含了以下数据：</p><ul><li><code>document-uri</code>: 发生违规的文档的URI。</li><li><code>referrer</code>: 违规发生处的文档引用（地址）。</li><li><code>blocked-uri</code>: 被CSP阻止的资源URI。如果被阻止的URI来自不同的源而非文档URI，那么被阻止的资源URI会被删减，仅保留协议，主机和端口号。</li><li><code>violated-directive</code>: 违反的策略名称。</li><li><code>original-policy</code>: 在 Content-Security-Policy HTTP 头部中指明的原始策略。</li></ul></blockquote><h3 id="CSP的策略指令"><a href="#CSP的策略指令" class="headerlink" title="CSP的策略指令"></a>CSP的策略指令</h3><ul><li>常见策略类型</li></ul><table><thead><tr><th>策略指令</th><th>策略说明</th></tr></thead><tbody><tr><td>default-src</td><td>默认加载策略</td></tr><tr><td>script-src</td><td>外部脚本</td></tr><tr><td>style-src</td><td>样式表</td></tr><tr><td>img-src</td><td>图像</td></tr><tr><td>media-src</td><td>媒体文件（音频和视频）</td></tr><tr><td>font-src</td><td>字体文件</td></tr><tr><td>object-src</td><td>插件（比如 Flash）</td></tr><tr><td>child-src</td><td>框架</td></tr><tr><td>frame-ancestors</td><td>嵌入的外部资源（比如<code>&lt;iframe&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;applet&gt;</code>）</td></tr><tr><td>connect-src</td><td>HTTP 连接（通过 XHR、WebSockets、EventSource等）</td></tr><tr><td>worker-src</td><td>worker脚本</td></tr><tr><td>manifest-src</td><td>manifest 文件</td></tr></tbody></table><p><strong>想要了解策略的全部类型可以查看<a href="https://www.w3.org/TR/CSP2/#directives" target="_blank" rel="noopener">这里</a></strong></p><ul><li>策略值类型</li></ul><table><thead><tr><th>指令值</th><th>指令值说明</th></tr></thead><tbody><tr><td>*</td><td>允许任何内容</td></tr><tr><td>‘none’</td><td>不允许任何内容</td></tr><tr><td>‘self’</td><td>允许来自相同来源的内容（相同的协议、域名和端口）</td></tr><tr><td>data:</td><td>允许 data: 协议（如 base64 编码的图片）</td></tr><tr><td><a href="http://www.Google.com" target="_blank" rel="noopener">www.Google.com</a></td><td>允许加载指定域名的资源</td></tr><tr><td>*.Google.com</td><td>允许加载 Google.com 任何子域的资源</td></tr><tr><td>‘unsafe-inline’</td><td>允许使用内联资源,如内联的 <code>&lt;script&gt;</code> 元素、javascript: URL、内联的事件处理函数和内联的 <code>&lt;style&gt;</code> 元素.两侧单引号是必须的.</td></tr><tr><td>‘unsafe-eval’</td><td>允许使用<code>eval()</code>等通过字符串创建代码的方法。两侧单引号是必须的。</td></tr></tbody></table><h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><h3 id="Content-Security-Policy-Level-1"><a href="#Content-Security-Policy-Level-1" class="headerlink" title="Content Security Policy Level 1"></a>Content Security Policy Level 1</h3><p><img src="https://user-gold-cdn.xitu.io/2019/2/20/16906958eb002cb6?w=2354&h=1046&f=png&s=261871" alt="CSP1"></p><h3 id="Content-Security-Policy-Level-2"><a href="#Content-Security-Policy-Level-2" class="headerlink" title="Content Security Policy Level 2"></a>Content Security Policy Level 2</h3><p><img src="https://user-gold-cdn.xitu.io/2019/2/20/1690695d7064cd04?w=2352&h=1166&f=png&s=303992" alt="CSP2"></p><p>上面是我的一些粗浅的总结,希望对大家有所帮助.如果文中有何不当之处请予以斧正,谢谢.</p><p><strong>参考资料:</strong></p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">MDN—CSP</a></p></li><li><p><a href="https://www.w3.org/TR/CSP2/" target="_blank" rel="noopener">W3C—Content Security Policy Level 2</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">阮一峰—Content Security Policy 入门教程</a></p></li></ul><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新一代的前端存储方案--indexedDB</title>
      <link href="/2018/05/03/%E6%96%B0%E4%B8%80%E4%BB%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88--indexedDB/"/>
      <url>/2018/05/03/%E6%96%B0%E4%B8%80%E4%BB%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88--indexedDB/</url>
      
        <content type="html"><![CDATA[<h1 id="前端存储"><a href="#前端存储" class="headerlink" title="前端存储"></a>前端存储</h1><p>&emsp;&emsp;我们都知道在前端开发当中,有时会因为某些需求,要将一些数据存储在前端本地当中.比如说:为了优化性能,将一些常用的数据存在本地,这样以后需要的时候直接从本地拿,不需要再向后端进行请求.还有就是为了防止CSRF攻击,后端给前端一个token,前端就需要将这个token存在本地.之后每次请求都需要带上这个token.等等不一而足.</p><p>&emsp;&emsp;而这些需求就不油避免的造就一个前端的发展方向–<strong>前端存储</strong></p><p>&emsp;&emsp;在前端的’上古时代’里,我们前端想要存储数据,只有一种方式,那就是<code>Cookie</code>.但是<code>Cookie</code>虽然可以做前端存储方案,但是却也有着很多局限性.首先它的存储空间大小只有4K,其次它的存储有效时间有限制,然后存在<code>Cookie</code>中的数据,在你每次进行请求的时候都会将它带上.使得每次的请求数据都会无意义的增大.最后,也是最重要的一点.<code>Cookie</code>设计之初就不是就是让我们前端存数据用的.它只是为了让网站验证用户身份用的.至于<code>Cookie</code>的本地存储功能只是它的一个手段而已.关于这点你们可以看下我的另外一篇文章—<a href="https://juejin.im/post/59708bbe518825103c098332" target="_blank" rel="noopener">在HTML5的时代,重新认识Cookie</a></p><p>&emsp;&emsp;综上所述,使用<code>Cookie</code>作为前端存储有这许多缺点,所以经过前端社区的不断努力,在HTML5中有了真正的前端存储方案<code>Web Storage</code>.它分为两种,一种是永久存储的<code>localStorage</code>,一种是会话期间存储的<code>sessionStorage</code>.对比<code>Cookie</code>,<code>Web Storage</code>的优势很明显:</p><blockquote><ol><li>存储空间更大,有5M大小</li><li>在浏览器发送请求是不会带上<code>web Storage</code>里的数据</li><li>更加友好的API</li><li>可以做永久存储(localStorage).</li></ol></blockquote><p>&emsp;&emsp;这一切看起来很完美,但是随着前端的不断发展,<code>web Storage</code>也有了一些不太合适的地方:</p><blockquote><ol><li>随着web应用程序的不断发展,5M的存储大小对于一些大型的web应用程序来说有些不够</li><li><code>web Storage</code>只能存储<code>string</code>类型的数据.对于<code>Object</code>类型的数据只能先用<code>JSON.stringify()</code>转换一下在存储.</li></ol></blockquote><p>&emsp;&emsp;基于上述原因,前端社区又提出了浏览器数据库存储这个概念.而<code>Web SQL Database</code>和<code>indexedDB(索引数据库)</code>是对这个概念的实现.其中<code>Web SQL Database</code>在目前来说基本已经被放弃.所以目前主流的浏览器数据库的实现就是<code>indexedDB(索引数据库)</code>.也就是我们要介绍的 <strong>新一代的前端存储方案–indexedDB</strong></p><h2 id="什么是indexedDB"><a href="#什么是indexedDB" class="headerlink" title="什么是indexedDB"></a>什么是indexedDB</h2><h3 id="indexedDB的介绍"><a href="#indexedDB的介绍" class="headerlink" title="indexedDB的介绍"></a>indexedDB的介绍</h3><blockquote><p>IndexedDB 是一种使用浏览器存储大量数据的方法.它创造的数据可以被查询，并且可以离线使用. IndexedDB对于那些需要存储大量数据，或者是需要离线使用的程序是非常有效的解决方法.  — MDN</p></blockquote><h3 id="indexedDB的概念"><a href="#indexedDB的概念" class="headerlink" title="indexedDB的概念"></a>indexedDB的概念</h3><blockquote><p>&emsp;&emsp;使用IndexedDB，你可以存储或者获取数据，使用一个key索引的。 你可以在事务(transaction)中完成对数据的修改。和大多数web存储解决方案相同，indexedDB也遵从同源协议(same-origin policy). 所以你只能访问同域中存储的数据，而不能访问其他域的。<br>&emsp;&emsp;API包含异步(asynchronous) API 和同步(synchronous)API两种。  异步API适合大多数情况, 同步API必须同 WebWorkers一同使用. 目前，没有主流浏览器支持同步API。 即使同步API被支持了，你也会在大多数的情况使用异步API。<br>&emsp;&emsp;IndexedDB 是 WebSQL 数据库的取代品, W3C组织在2010年11月18日废弃了webSql.  IndexedDB 和WebSQL的不同点在于WebSQL 是关系型数据库（复杂）IndexedDB 是key-value型数据库（简单好使）.</p></blockquote><p>&emsp;&emsp;上面是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB" target="_blank" rel="noopener">MDN</a>上对于IndexedDB的介绍.其简单而言,indexedDB就是一个基于事务操作的key-value型数前端数据库.其API大多是异步的</p><h2 id="indexedDB的使用"><a href="#indexedDB的使用" class="headerlink" title="indexedDB的使用"></a>indexedDB的使用</h2><h3 id="创建一个indexedDB数据库"><a href="#创建一个indexedDB数据库" class="headerlink" title="创建一个indexedDB数据库"></a>创建一个indexedDB数据库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = indexedDB.open(<span class="string">'myDatabase'</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">request.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"连接数据库成功"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">request.addEventListener(<span class="string">'error'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"连接数据库失败"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面代码中我们使用<code>indexedDB.open()</code>创建一个<code>indexedDB</code>数据库.<code>open()</code>方法接受可以接受两个参数.第一个是数据库名,第二个是数据库的版本号.同时返回一个<code>IDBOpenDBRequest</code>对象用于操作数据库.其中对于<code>open()</code>的第一个参数数据库名,<code>open()</code>会先去查找本地是否已有这个数据库,如果有则直接将这个数据库返回,如果没有,则先创建这个数据库,再返回.对于第二个参数版本号,则是一个可选参数,如果不传,默认为1.但如果传入就必须是一个整数.</p><p>&emsp;&emsp;在通过对<code>indexedDB.open()</code>方法拿到一个数据库对象<code>IDBOpenDBRequest</code>我们可以通过监听这个对象的<code>success</code>事件和<code>error</code>事件来执行相应的操作.</p><h3 id="创建一个对象仓库"><a href="#创建一个对象仓库" class="headerlink" title="创建一个对象仓库"></a>创建一个对象仓库</h3><p>&emsp;&emsp;再有了一个数据库之后,我们获取就想要去存储数据了,但是单只有数据库还不够,我们还需要有对象仓库(object store).对象仓库(object store)是indexedDB数据库的基础,其类似于MySQL中表的概念.</p><blockquote><p>&emsp;&emsp;要创建一个对象仓库必须在<code>upgradeneeded</code>事件中,而<code>upgradeneeded</code>事件只会在版本号更新的时候触发.这是因为<code>indexedDB API</code>中不允许数据库中的数据仓库在同一版本中发生变化</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = indexedDB.open(<span class="string">'myDatabase'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">request.addEventListener(<span class="string">'upgradeneeded'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> db = e.target.result;</span><br><span class="line">    <span class="keyword">const</span>  store = db.createObjectStore(<span class="string">'Users'</span>, &#123;<span class="attr">keyPath</span>: <span class="string">'userId'</span>, <span class="attr">autoIncrement</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建对象仓库成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中我们监听<code>upgradeneeded</code>事件,并在这个事件触发时使用<code>createObjectStore()</code>方法创建了一个对象仓库.<code>createObjectStore()</code>方法接受两个参数,第一个是对象仓库的名字,在同一数据库中,仓库名不能重复.第二个是可选参数.用于指定数据的主键,以及是否自增主键.</p><h3 id="创建事务"><a href="#创建事务" class="headerlink" title="创建事务"></a>创建事务</h3><p>&emsp;&emsp;OK现在我们有了数据库和对象仓库了,我们是否就可以存储数据了了.很抱歉,还是不行.我们还差最后一样东西—-事务.</p><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><blockquote><p>&emsp;&emsp;一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的</p><ol><li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</li><li>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li></ol></blockquote><blockquote><p>&emsp;&emsp;并非任意的对数据库的操作序列都是数据库事务。数据库事务拥有以下四个特性，习惯上被称之为ACID特性。  </p><ul><li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li><li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li><li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中</li></ul></blockquote><p>&emsp;&emsp;上面是维基百科上对数据库事务的解释.简单来说事务就是用来保证数据库操作要么全部成功,要么全部失败的一个限制.比如,在修改多条数据时,前面几条已经成功了.,在中间的某一条是失败了.那么在这时,如果是基于事务的数据库操作,那么这时数据库就应该重置前面数据的修改,放弃后面的数据修改.直接返回错误,一条数据也不修改.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = indexedDB.open(<span class="string">'myDatabase'</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">request.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> db = e.target.result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction(<span class="string">'Users'</span>,<span class="string">'readwrite'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码中我们使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase/transaction" target="_blank" rel="noopener">transaction()</a>来创建一个事务.<code>transaction()</code>接受两个参数,第一个是你要操作的对象仓库名称,第二个是你创建的事务模式.传入 <code>readonly</code>时只能对对象仓库进行读操作,无法写操作.可以传入<code>readwrite</code>进行读写操作.</p><h3 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h3><p>&emsp;&emsp;好了现在有了数据库,对象仓库,事务之后我们终于可以存储数据了.</p><ul><li>add() : 增加数据。接收一个参数，为需要保存到对象仓库中的对象。</li><li>put() : 增加或修改数据。接收一个参数，为需要保存到对象仓库中的对象。</li><li>get() : 获取数据。接收一个参数，为需要获取数据的主键值。</li><li>delete() : 删除数据。接收一个参数，为需要获取数据的主键值。</li></ul><blockquote><p>add 和 put 的作用类似，区别在于 put 保存数据时，如果该数据的主键在数据库中已经有相同主键的时候，则会修改数据库中对应主键的对象，而使用 add 保存数据，如果该主键已经存在，则保存失败。</p></blockquote><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = indexedDB.open(<span class="string">'myDatabase'</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">request.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> db = e.target.result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction(<span class="string">'Users'</span>,<span class="string">'readwrite'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> store = tx.objectStore(<span class="string">'Users'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存数据</span></span><br><span class="line">    <span class="keyword">const</span> reqAdd = store.add(&#123;<span class="string">'userId'</span>: <span class="number">1</span>, <span class="string">'userName'</span>: <span class="string">'李白'</span>, <span class="string">'age'</span>: <span class="number">24</span>&#125;);</span><br><span class="line"></span><br><span class="line">    reqAdd.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'保存成功'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = indexedDB.open(<span class="string">'myDatabase'</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">request.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> db = e.target.result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction(<span class="string">'Users'</span>,<span class="string">'readwrite'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> store = tx.objectStore(<span class="string">'Users'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="keyword">const</span> reqGet = store.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    reqGet.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.result.userName);    <span class="comment">// 李白</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = indexedDB.open(<span class="string">'myDatabase'</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">request.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> db = e.target.result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction(<span class="string">'Users'</span>,<span class="string">'readwrite'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> store = tx.objectStore(<span class="string">'Users'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除数据</span></span><br><span class="line">    <span class="keyword">const</span> reqDelete = store.delete(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    reqDelete.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'删除数据成功'</span>);    <span class="comment">// 李白</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h3><p>&emsp;&emsp;在上面当中我们使用<code>get()</code>方法传入一个主键来获取数据,但是这样只能够获取到一条数据.如果我们想要获取多条数据了怎么办.我们可以使用游标,来获取一个区间内的数据.</p><p>&emsp;&emsp;要使用游标,我们需要使用对象仓库上的<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBIndex/openCursor" target="_blank" rel="noopener">openCursor()</a>方法创建币打开.<code>openCursor()</code>方法接受两个参数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openCursor(range?: IDBKeyRange | number | string | <span class="built_in">Date</span> | IDBArrayKey, direction?: IDBCursorDirection): IDBRequest;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一个是范围,范围可以是一个<code>IDBKeyRange</code>对象.用以下方式创建.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boundRange 表示主键值从1到10(包含1和10)的集合。</span></span><br><span class="line"><span class="comment">// 如果第三个参数为true，则表示不包含最小键值1，如果第四参数为true，则表示不包含最大键值10，默认都为false</span></span><br><span class="line"><span class="keyword">var</span> boundRange = IDBKeyRange.bound(<span class="number">1</span>, <span class="number">10</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// onlyRange 表示由一个主键值的集合。only() 参数则为主键值，整数类型。</span></span><br><span class="line"><span class="keyword">var</span> onlyRange = IDBKeyRange.only(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lowerRaneg 表示大于等于1的主键值的集合。</span></span><br><span class="line"><span class="comment">// 第二个参数可选，为true则表示不包含最小主键1，false则包含，默认为false</span></span><br><span class="line"><span class="keyword">var</span> lowerRange = IDBKeyRange.lowerBound(<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// upperRange 表示小于等于10的主键值的集合。</span></span><br><span class="line"><span class="comment">// 第二个参数可选，为true则表示不包含最大主键10，false则包含，默认为false</span></span><br><span class="line"><span class="keyword">var</span> upperRange = IDBKeyRange.upperBound(<span class="number">10</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二个参数是方向.主要有一下几种</p><blockquote><ul><li>next : 游标中的数据按主键值升序排列，主键值相等的数据都被读取</li><li>nextunique : 游标中的数据按主键值升序排列，主键值相等只读取第一条数据</li><li>prev : 游标中的数据按主键值降序排列，主键值相等的数据都被读取</li><li>prevunique : 游标中的数据按主键值降序排列，主键值相等只读取第一条数据</li></ul></blockquote><p>&emsp;&emsp;下面让我们来看一个完整的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = indexedDB.open(<span class="string">'myDatabase'</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">request.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> db = e.target.result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction(<span class="string">'Users'</span>,<span class="string">'readwrite'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> store = tx.objectStore(<span class="string">'Users'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> range = IDBKeyRange.bound(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> req = store.openCursor(range, <span class="string">'next'</span>);</span><br><span class="line"></span><br><span class="line">    req.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> cursor = <span class="keyword">this</span>.result;</span><br><span class="line">        <span class="keyword">if</span>(cursor)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(cursor.value.userName);</span><br><span class="line">            cursor.continue();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'检索结束'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的代码中如果检索到符合条件的数据时,我们可以:</p><blockquote><ul><li>使用<code>cursor.value</code>拿到数据.</li><li>使用<code>cursor.updata()</code>更新数据.</li><li>使用<code>cursor.delete()</code>删除数据.</li><li>使用<code>cursor.continue()</code>读取下一条数据.</li></ul></blockquote><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>&emsp;&emsp;在上面代码中我们获取数据都是用的主键.但是,在很多情况下我们并不知道我们需要数据的主键是什么,我们知道一个大概的条件.比如说年龄大于20岁的用户.这个时候我们就需要用到<strong>索引</strong>.以便有条件的查找.</p><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>&emsp;&emsp;我们使用对象仓库的<a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/createIndex" target="_blank" rel="noopener">createIndex()</a>方法来创建一个索引.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createIndex(name: string, <span class="attr">keyPath</span>: string | string[], optionalParameters?: IDBIndexParameters): IDBIndex;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>createIndex()</code>方法接收三个参数:</p><ol><li><p>第一个参数<code>name</code>是索引名,不能重复.</p></li><li><p>第二个参数<code>keyPath</code>是你要在存储对象上的那个属性上建立索引,可以是一个单个的key值,也可以是一个包含key值集合的数组.</p></li><li><p>第三个参数<code>optionalParameters</code>是一个可选的对象参数<code>{unique, multiEntry}</code></p><ul><li>unique: 用来指定索引值是否可以重复,为true代表不能相同,为false时代表可以相同</li><li>multiEntry: 当第二个参数<code>keyPath</code>为一个数组时.如果<code>multiEntry</code>是true,则会以数组中的每个元素建立一条索引.如果是false,则以整个数组为<code>keyPath</code>值,添加一条索引.</li></ul></li></ol><p>&emsp;&emsp;下面让我们来看一个完整的例子,我们建立一条用户年龄的索引.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = indexedDB.open(<span class="string">'myDatabase'</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">request.addEventListener(<span class="string">'upgradeneeded'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> db = e.target.result;</span><br><span class="line">    <span class="keyword">const</span>  store = db.createObjectStore(<span class="string">'Users'</span>, &#123;<span class="attr">keyPath</span>: <span class="string">'userId'</span>, <span class="attr">autoIncrement</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> idx = store.createIndex(<span class="string">'ageIndex'</span>,<span class="string">'age'</span>,&#123;<span class="attr">unique</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样我们就创建了一条索引.</p><h4 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h4><p>&emsp;&emsp;这在创建了一条索引之后我们就可以来使用它了.我们使用对象仓库上的<code>index</code>方法,通过传入一个索引名.来拿到一个索引对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = store.index(<span class="string">'ageIndex'</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们就可以使用这个索引了.比如说我们要拿到年龄在20岁以上的数据,升序排列.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = indexedDB.open(<span class="string">'myDatabase'</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">request.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> db = e.target.result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tx = db.transaction(<span class="string">'Users'</span>,<span class="string">'readwrite'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> store = tx.objectStore(<span class="string">'Users'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> index = store.index(<span class="string">'ageIndex'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> req = index.openCursor(IDBKeyRange.lowerBound(<span class="number">20</span>), <span class="string">'next'</span>);</span><br><span class="line"></span><br><span class="line">    req.addEventListener(<span class="string">'success'</span>, e =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> cursor = e.target.result;</span><br><span class="line">        <span class="keyword">if</span>(cursor)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(cursor.value.age);</span><br><span class="line">            cursor.continue();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'检索结束'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="indexedDB的兼容性"><a href="#indexedDB的兼容性" class="headerlink" title="indexedDB的兼容性"></a>indexedDB的兼容性</h2><p><img src="https://user-gold-cdn.xitu.io/2018/5/27/163a05e409de5bd7?w=2350&h=1002&f=png&s=218892" alt></p><p>上面是我对indexedDB一些粗浅的总结,希望对大家有所帮助.如果文中有何不当之处请予以斧正,谢谢.</p><p><strong>参考资料:</strong></p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">MDN—IndexedDB</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB" target="_blank" rel="noopener">MDN—基本概念</a></p></li><li><p><a href="https://juejin.im/post/59013d2c0ce46300614ebe70" target="_blank" rel="noopener">HTML5 进阶系列：indexedDB 数据库</a></p></li></ul><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的装饰器--Decorator</title>
      <link href="/2018/03/21/JavaScript%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8--Decorator/"/>
      <url>/2018/03/21/JavaScript%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8--Decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Decorator"><a href="#什么是Decorator" class="headerlink" title="什么是Decorator"></a>什么是Decorator</h1><blockquote><p>&emsp;&emsp;修饰模式(Decortaor)，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。</p></blockquote><h2 id="Decorator的作用"><a href="#Decorator的作用" class="headerlink" title="Decorator的作用"></a>Decorator的作用</h2><blockquote><p>&emsp;&emsp;通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。<br>&emsp;&emsp;修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。<br>&emsp;&emsp;当有几个相互独立的功能需要扩充时，这个区别就变得很重要。在有些&gt;面向对象的编程语言中，类不能在运行时被创建，通常在设计的时候也不能预测到有哪几种功能组合。这就意味著要为每一种组合创建一个新类。相反，修饰模式是面向运行时候的对象实例的,这样就可以在运行时根据需要进行组合。一个修饰模式的示例是JAVA里的Java I/O Streams的实现。</p></blockquote><p>&emsp;&emsp;上面两段是维基百科中对于<code>Decorator</code>装饰器模式的介绍.简单来说.<code>Decorator</code>就是一种<strong>动态地往一个类中添加新的行为的设计模式</strong>,它可以在类运行时,扩展一个类的功能.并且去修改类本身的属性和方法.使其可以在不同类之间更灵活的共用一些属性和方法.下面就让我们来看下在ES中<code>Decorator</code>的用法.</p><h2 id="Decorator的用法"><a href="#Decorator的用法" class="headerlink" title="Decorator的用法"></a>Decorator的用法</h2><h3 id="类本身的修饰"><a href="#类本身的修饰" class="headerlink" title="类本身的修饰"></a>类本身的修饰</h3><p>&emsp;&emsp;在ES中<code>Decorator</code>的具体表现形式为:</p><blockquote><p>一个求值结果为函数的表达式，接受目标对象、名称和装饰器描述作为参数，可选地返回一个装饰器描述来安装到目标对象上。</p></blockquote><p>所以说在ES中<code>Decorator</code>的最终本质就是一个函数,这个函数通过接受目标对象的三个参数: <em>所装饰的类的本身<em>、</em>所装饰的类的某个属性的key值<em>、</em>所装饰的类的某个属性的描述对象</em>.并通过对这三个参数的操作,已达到为类扩展功能的目的.下面然我们来用具体代码来演示一下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@eat</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eat</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'吃饭'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">  <span class="built_in">console</span>.log(descriptor)</span><br><span class="line">  target.prototype.act = <span class="string">'我要吃饭'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jack = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(jack.act);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吃饭</span></span><br><span class="line"><span class="comment">// [Function: Person]</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 我要吃饭</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面是一个最简单的装饰器的运用.我们首先声明一个类<code>Person</code>,然后在声明一个装饰器函数<code>eat</code>,在<code>eat</code>中将传入的三个参数分别打印出来,并将第一个参数<code>target</code>的原型<code>prototype</code>上添加一个属性<code>act</code>,并赋值为’我要吃饭’.然后将函数<code>eat</code>作为装饰在<code>Person</code>这个类本身上.最后,构造一个<code>Person</code>的实例<code>jack</code>,并打印<code>jack</code>上的<code>act</code>属性.</p><p>&emsp;&emsp;然后从下面的运行结果中我们可以看出,代码中会先打印出’吃饭’,然后是参数<code>target</code>,其次是参数<code>key</code>,再然后是参数<code>descriptor</code>.最后才是<code>jack</code>的<code>act</code>属性.这是因为装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。</p><h3 id="类的属性的修饰"><a href="#类的属性的修饰" class="headerlink" title="类的属性的修饰"></a>类的属性的修饰</h3><p>&emsp;&emsp;看了上面那段代码的运行结果,你可能会用这么一个疑问.<code>Decorator</code>所传进来的三个参数: <code>target</code>、<code>key</code>、<code>descriptor</code>.为什么只有<code>target</code>有值,而<code>key</code>和<code>descriptor</code>则都是<code>undefined</code>了.事实上这是因为你将装饰器<code>Decorator</code>装饰在类本身上所导致的.在ES中装饰器并不仅仅只能装饰在类本身上,也可以装饰在类的属性上.当装饰在类的属性上时.<code>key</code>和<code>descriptor</code>也就有了用武之地.请看下面这段代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @test</span><br><span class="line">    name() &#123;<span class="built_in">console</span>.log(<span class="string">'张三'</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target);</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">  <span class="built_in">console</span>.log(descriptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">student.name();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person &#123;&#125;</span></span><br><span class="line"><span class="comment">// name</span></span><br><span class="line"><span class="comment">// &#123; value: [Function: name], writable: true, enumerable: false, configurable: true &#125;</span></span><br><span class="line"><span class="comment">// 张三</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面代码中我们将<code>test</code>装饰器装饰在<code>Person</code>类的<code>name</code>属性上.然后打印三个传入的入参.分别得到了我们期望的结果.而通过这三个参数,我们就可以对我们要装饰的对象进行一些有趣的修改, 如下面这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">    @test</span><br><span class="line">    name() &#123;<span class="built_in">console</span>.log(<span class="string">'张三'</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'李四'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">student.name();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李四</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面代码中,我们给一个类<code>Person</code>的原型上赋值了一个属性<code>name</code>,其值为一个函数,执行时会打印<code>张三</code>两个字.然后我们给属性<code>name</code>装饰了<code>test</code>这个装饰器.在<code>test</code>装饰器中,将传入进来的<code>descriptor</code>对象上的<code>value</code>赋值为一个函数,执行时打印<code>李四</code>两个字.最后构造一个实例<code>student</code>,并执行<code>name</code>方法,执行的结果是打印了<code>李四</code>两个字,这说明通过装饰器,我们完全可以在不改变一个类本身的请况下对一个类的属性进行改写.这使得在不同类中共享同一方法这一操作相当简单,且优雅.需要共享的使用使用装饰器,不需要的时候移除装饰器.完全不用对类的本身进行操作.</p><p>&emsp;&emsp;对于装饰器,如果我们感到,固定传入的三个参数不够用的话,我们也可以自行传入参数只需要像下面这么写:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rename</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">    descriptor.value = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面已经说过,在ES中<strong><code>Decorator</code>就是一个求值结果为函数的表达式,</strong>所以,只要你最后的返回结果是一个函数.都是一个合法的装饰器.</p><h3 id="Decorator的兼容性"><a href="#Decorator的兼容性" class="headerlink" title="Decorator的兼容性"></a>Decorator的兼容性</h3><p>&emsp;&emsp;目前ES中<code>Decorator</code>还处于提案阶段,各大浏览器和node,均为公开支持这一特性.如果想要使用,则需要借用<code>babel</code>的一个插件<code>babel-plugin-transform-decorators</code>才可以.</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>&emsp;&emsp;上面是我对<code>Decorator</code>的一些见解,希望对大家有所帮助.如果文中任有何不当之处请予以斧正,谢谢</p><p><strong>参考资料:</strong></p><ul><li><p><a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">阮一峰的ES6入门-decorator</a></p></li><li><p><a href="http://www.liuhaihua.cn/archives/115548.html" target="_blank" rel="noopener">Decorators in ES7</a></p></li></ul><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Decorator </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每个前端工程师都应该了解的HTML5.2</title>
      <link href="/2018/01/09/%E6%AF%8F%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84HTML5.2/"/>
      <url>/2018/01/09/%E6%AF%8F%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%83%BD%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84HTML5.2/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5-2的到来"><a href="#HTML5-2的到来" class="headerlink" title="HTML5.2的到来"></a>HTML5.2的到来</h1><p>&emsp;&emsp;一般在W3C当中.对版本的发布会经过四个阶段分别是:工作草案（WD）、备选推荐标准（CR）、提案推荐标准（PR）和最终的W3C正式推荐标准（REC）.而当一个规范到达REC阶段时，就意味着它已经得到了W3C成员的正式认可，并推荐它由用户代理部署，前端工程师进行使用。</p><p>&emsp;&emsp;现在,就在2017年12月14日W3C发布了<a href="https://www.w3.org/TR/2017/REC-html52-20171214/index.html" target="_blank" rel="noopener">HTML规范5.2更新版本</a>,这个版本相对之前的版本来说有了一些增加和删除.对于这些变更,都可以在<a href="https://www.w3.org/TR/html52/changes.html#changes" target="_blank" rel="noopener">HTML 5.2 Changes</a>这个页面上看到.而下面我会对这些变更中某些内容进行介绍.</p><h2 id="新增的dialog元素"><a href="#新增的dialog元素" class="headerlink" title="新增的dialog元素"></a>新增的dialog元素</h2><p>&emsp;&emsp;在HTML5.2中新增了dialog这个标签.来帮助我们快速实现一个对话框.在HTML5.2之前我们想实现一个对话框功能,大概的实现方式的是:一个<code>div</code>,先将它<code>display: none</code>隐藏掉.然后在需要的地方再讲其<code>display</code>置为<code>black</code>.这样就能控制一个对话框的显示和隐藏.而在HTML5.2中,你只需要这写:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dialog id=<span class="string">"dialog"</span>&gt;</span><br><span class="line">    &lt;h2&gt;我是对话框标题&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;我是对话框内容&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/dialog&gt;</span></span><br></pre></td></tr></table></figure><p>就可以得到一个对话框.默认情况下这个对话框是隐藏的,你可以给他添加<code>open</code>属性让他显示出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dialog id=<span class="string">"dialog"</span> open&gt;</span><br><span class="line">    &lt;h2&gt;我是对话框标题&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;我是对话框内容&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/dialog&gt;</span></span><br></pre></td></tr></table></figure><p>同时,也可以拿到这个<code>dialog</code>元素,然后调用它的<code>show()</code>方法让他显示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dialog id=<span class="string">"dialog"</span> open&gt;</span><br><span class="line">    &lt;h2&gt;我是对话框标题&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;我是对话框内容&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/dialog&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const dialog = document.querySelector('#dialog').show();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>同样的,如果那你想要这个对话框隐藏,只需要调用这个<code>dialog</code>元素的<code>close()</code>方法即可</p><p>此外,当你想要在显示对话框的同时,有一个遮罩层的话.你可以使用<code>showModal()</code>这个方法.它会在显示对话框的同时,在你页面的顶层显示一个遮罩层,以防止你去操作除对话框以外的它元素.另外要注意一点的是<code>open</code>属性和<code>showModal()</code>不能同时使用,否则会报;<code>Untitled-1.html:28 Uncaught DOMException: Failed to execute &#39;showModal&#39; on &#39;HTMLDialogElement&#39;: The element already has an &#39;open&#39; attribute, and therefore cannot be opened modally.</code>这个错误</p><p>最后<code>dialog</code>的兼容性如下:</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/9/160db412504765b1?w=2356&h=984&f=png&s=207963" alt></p><h2 id="支付请求API-—-allowpaymentrequest"><a href="#支付请求API-—-allowpaymentrequest" class="headerlink" title="支付请求API — allowpaymentrequest"></a>支付请求API — allowpaymentrequest</h2><p>在HTML5.2之前.对于支付请求的API是不能在iframe中来完成的.所以每次我们在进行移动支付时都需要跳转到另外一个支付页面才能完成付款.而现在,使用<code>allowpaymentrequest</code>属性应用在<code>iframe</code>上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe allowpaymentrequest&gt;</span><br></pre></td></tr></table></figure><p>这样,就可以让<code>iframe</code>使用<code>Payment Request API</code>从而让</p><blockquote><p>嵌入了第三方内容的页面能够控制该第三方内容是否可向用户请求获取支付凭证，进而让可嵌入的购物车工具可以利用Payment Request API。</p></blockquote><blockquote><p>来自Forrester的Brendan Miller阐述了支付请求API所带来的好处，他说：该新标准让开发者可以创建一个简化的结帐页面，用户可以重复使用保存的付款和地址信息来加快结账速度，并减少错误输入。</p></blockquote><p>Payment Request API的兼容性:</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/9/160db4167d52b852?w=2352&h=930&f=png&s=196010" alt></p><h2 id="在页面上同时使用多个main标签"><a href="#在页面上同时使用多个main标签" class="headerlink" title="在页面上同时使用多个main标签"></a>在页面上同时使用多个<code>main</code>标签</h2><blockquote><p>HTML Main元素<code>&lt;main&gt;</code>呈现了文档<code>&lt;body&gt;</code>或应用的主体部分。主体部分由与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成。这部分内容在文档中应当是独一无二的，不包含任何在一系列文档中重复的内容，比如侧边栏，导航栏链接，版权信息，网站logo，搜索框（除非搜索框作为文档的主要功能）。</p></blockquote><p>上面是一段是MDN上对于<code>&lt;main&gt;</code>标签的介绍.其中说明了<code>&lt;main&gt;</code>标签中的内容应该是文档的主题内容,并且是独一无二的.所以,在这段介绍后面有一点注意<strong>在一个文档中 不能 出现一个以上的<code>&lt;main&gt;</code>标签</strong></p><p>而现在,随着单页面应用(SPA)的越来越流行.使得这一特性的已经不符合当下的实景,所以在HTML5.2中.在页面中同时出现多个<code>&lt;main&gt;</code>标签是被允许的.只要在同一时间内,只有一个<code>&lt;main&gt;</code>标签是对外显示的,其他所有都是被<code>hidden</code>属性隐藏的即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;main&gt;...&lt;<span class="regexp">/main&gt;</span></span><br><span class="line"><span class="regexp">&lt;main hidden&gt;...&lt;/m</span>ain&gt;</span><br><span class="line">&lt;main hidden&gt;...&lt;<span class="regexp">/main&gt;</span></span><br></pre></td></tr></table></figure><p>此外要注意,隐藏<code>&lt;main&gt;</code>标签的方法必须是使用<code>hidden</code>属性才行.其它的如:<code>display: none</code>、透明的为0等方法不行.这会让<code>&lt;main&gt;</code>标签失去自己的语义和作用.</p><h2 id="被删除的属性和元素"><a href="#被删除的属性和元素" class="headerlink" title="被删除的属性和元素"></a>被删除的属性和元素</h2><h3 id="被删除的元素"><a href="#被删除的元素" class="headerlink" title="被删除的元素"></a>被删除的元素</h3><ul><li><p>keygen：用于帮助生成表单的公钥</p></li><li><p>menu和menuitem：用于创建导航或上下文菜单</p></li></ul><h3 id="被删除的属性"><a href="#被删除的属性" class="headerlink" title="被删除的属性"></a>被删除的属性</h3><ul><li><p>Window.showModalDialog(): 创建并显示一个包含指定HTML文档的模态框。</p></li><li><p>插件API: 提供有关浏览器插件的信息 .</p></li></ul><h2 id="废弃的HTML头部声明"><a href="#废弃的HTML头部声明" class="headerlink" title="废弃的HTML头部声明"></a>废弃的HTML头部声明</h2><p>以下两种HTML的头部声明已在HTML中废弃</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</span></span><br></pre></td></tr></table></figure><p>上面是我HTML5.2的一些粗浅的总结,希望对大家有所帮助.如果文中有何不当之处请予以斧正,谢谢.</p><p><strong>参考资料</strong></p><ul><li><p><a href="https://bitsofco.de/whats-new-in-html-5-2/?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">What’s New in HTML 5.2?</a></p></li><li><p><a href="http://www.infoq.com/cn/news/2018/01/html-5-2-recommendation" target="_blank" rel="noopener">W3C官方推荐使用新发布的HTML5.2</a></p></li></ul><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6中的代理模式-----Proxy</title>
      <link href="/2018/01/07/ES6%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-----Proxy/"/>
      <url>/2018/01/07/ES6%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-----Proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h1><blockquote><p>代理模式（英语：Proxy Pattern）是程序设计中的一种设计模式。</p></blockquote><blockquote><p>所谓的代理者是指一个类别可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、内存中的大对象、文件或其它昂贵或无法复制的资源。</p></blockquote><blockquote><p>著名的代理模式例子为引用计数（英语：reference counting）指针对象。</p></blockquote><blockquote><p>当一个复杂对象的多份副本须存在时，代理模式可以结合享元模式以减少内存用量。典型作法是创建一个复杂对象及多个代理者，每个代理者会引用到原本的复杂对象。而作用在代理者的运算会转送到原本对象。一旦所有的代理者都不存在时，复杂对象会被移除。</p></blockquote><p>上面是维基百科中对代理模式的一个整体的定义.而在JavaScript中代理模式的具体表现形式就是ES6中的新增对象—<strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy</a></strong></p><h2 id="什么是Proxy对象"><a href="#什么是Proxy对象" class="headerlink" title="什么是Proxy对象"></a>什么是Proxy对象</h2><p>在MDN上对于<code>Proxy</code>的解释是:</p><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p></blockquote><p>&emsp;&emsp;简单来说:<code>Proxy</code>对象就是可以让你去对JavaScript中的一切合法对象的基本操作进行自定义.然后用你自定义的操作去覆盖其对象的基本操作.也就是当一个对象去执行一个基本操作时,其执行的过程和结果是你自定义的,而不是对象的.</p><p>😓好吧,用文字表达可能太复杂了.我们还是直接上代码吧.</p><p>首先Proxy的语法是:</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><p><code>target</code>是你要代理的对象.它可以是JavaScript中的任何合法对象.如: (数组, 对象, 函数等等)</p></li><li><p><code>handler</code>是你要自定义操作方法的一个集合.</p></li><li><p><code>p</code>是一个被代理后的新对象,它拥有<code>target</code>的一切属性和方法.只不过其行为和结果是在<code>handler</code>中自定义的.</p></li></ul><p>然后让我们来看这段代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'c'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'我是自定义的一个结果'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="number">4</span>) &#123;</span><br><span class="line">      target[key] = <span class="string">'我是自定义的一个结果'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.c) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(p.c) <span class="comment">// 我是自定义的一个结果</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">'李白'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 李白</span></span><br><span class="line">obj.age = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'李白'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// 李白</span></span><br><span class="line">p.age = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.age); <span class="comment">// 我是自定义的一个结果</span></span><br></pre></td></tr></table></figure><p>从上面这段代码中,我可以很清楚的看到<code>Proxy</code>对象的作用.即是之前所受的<strong>用于定义基本操作的自定义行为</strong>.同样的<code>get</code>和<code>set</code>操作.没有没代理的对象所得的结果是其JavaScript本身的执行机制运行计算后所得到的.而被代理了的对象的结果则是我们自定义的.</p><h3 id="Proxy所能代理的范围–handler"><a href="#Proxy所能代理的范围–handler" class="headerlink" title="Proxy所能代理的范围–handler"></a>Proxy所能代理的范围–handler</h3><p>在上面代码中,我们看到了构造一个代理对象时所传的第二个参数<code>handler</code>,这个<code>handler</code>对象是由<code>get</code>和<code>set</code>两个函数方法组成的.这两个方法会在一个对象被<code>get</code>和<code>set</code>时被调用执行,以代替原生对象上的操作.那么为什么在<code>handler</code>,定义<code>get</code>和<code>set</code>这两个函数名之后就代理对象上的<code>get</code>和<code>set</code>操作了呢?</p><p>实际上<code>handler</code>本身就是ES6所新设计的一个对象.它的作用就是用来<strong>自定义代理对象的各种可代理操作</strong>。它本身一共有13中方法,每种方法都可以代理一种操作.其13种方法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">handler.getPrototypeOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span></span><br><span class="line"></span><br><span class="line">handler.setPrototypeOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span></span><br><span class="line"></span><br><span class="line">handler.isExtensible()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span></span><br><span class="line"></span><br><span class="line">handler.preventExtensions()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span></span><br><span class="line"></span><br><span class="line">handler.getOwnPropertyDescriptor()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, "foo") 时。</span></span><br><span class="line"></span><br><span class="line">handler.defineProperty()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, "foo", &#123;&#125;) 时。</span></span><br><span class="line"></span><br><span class="line">handler.has()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 "foo" in proxy 时。</span></span><br><span class="line"></span><br><span class="line">handler.get()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span></span><br><span class="line"></span><br><span class="line">handler.set()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span></span><br><span class="line"></span><br><span class="line">handler.deleteProperty()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span></span><br><span class="line"></span><br><span class="line">handler.ownKeys()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span></span><br><span class="line"></span><br><span class="line">handler.apply()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span></span><br><span class="line"></span><br><span class="line">handler.construct()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span></span><br></pre></td></tr></table></figure><h3 id="Proxy的作用"><a href="#Proxy的作用" class="headerlink" title="Proxy的作用"></a>Proxy的作用</h3><p>对于代理模式<code>Proxy</code>的作用主要体现在三个方面:</p><p>1、 拦截和监视外部对对象的访问</p><p>2、 降低函数或类的复杂度</p><p>2、 在复杂操作前对操作进行校验或对所需资源进行管理</p><p>而对于这三个使用方面的具体表现大家可以参考这篇文章–<a href="https://www.w3cplus.com/javascript/use-cases-for-es6-proxies.html" target="_blank" rel="noopener">实例解析ES6 Proxy使用场景</a></p><h3 id="Proxy的兼容性"><a href="#Proxy的兼容性" class="headerlink" title="Proxy的兼容性"></a>Proxy的兼容性</h3><p><img src="https://user-gold-cdn.xitu.io/2018/1/7/160d0f48c3e56c42?w=2350&h=986&f=png&s=192887" alt></p><p>上面是我的一些粗浅的总结,希望对大家有所帮助.如果文中有何不当之处请予以斧正,谢谢.</p><p><strong>参考资料:</strong></p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">MDN—Proxy</a></p></li><li><p><a href="https://www.w3cplus.com/javascript/use-cases-for-es6-proxies.html" target="_blank" rel="noopener">实例解析ES6 Proxy使用场景</a></p></li></ul><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Proxy </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始RxJS</title>
      <link href="/2017/08/05/%E5%88%9D%E5%A7%8BRxJS/"/>
      <url>/2017/08/05/%E5%88%9D%E5%A7%8BRxJS/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Rx-JS"><a href="#什么是Rx-JS" class="headerlink" title="什么是Rx.JS"></a>什么是Rx.JS</h1><p>&emsp;&emsp;<code>Rx.JS</code>是英文 <strong>Reactive Extensions for JavaScript</strong> 的缩写.翻译成中文就是:JavaScript的响应式扩展.其主要的功能就是利用响应式编程的模式来实现JavaScript的异步式编程.<br>&emsp;&emsp;相对于JavaScript中其它的异步式解决方式(回调函数、Promise、Gender、async函数而言),Rx.JS有着更加强大的特性和更加优雅的写法.如(纯净性、流动性、值)。</p><h2 id="Rx-JS的基本概念"><a href="#Rx-JS的基本概念" class="headerlink" title="Rx.JS的基本概念"></a>Rx.JS的基本概念</h2><p>&emsp;&emsp;Rx.JS的响应式编程操作是结合了观察者模式、迭代模式以及函数式编程来实现的.它主要有着如下几个概念:</p><blockquote><ul><li>Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li><li>Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li><li>Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。</li><li>Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。</li><li>Subject (主体): 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li><li>Schedulers (调度器): 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。</li></ul></blockquote><p>&emsp;&emsp;下面,来让我们看一个简单的示例.<br>&emsp;&emsp;我们都知道,在前端开发当中为性能的优化,我们往往会对某个持续不断会触发的事件做一下事件节流.,也就是事件增加一个<code>节流阀</code>,以限制事件的不断触发.最常见的做法就是设定一个定时器.来进行判断.事件在多少秒之内不断触发的话.就将<code>节流阀</code>打开.不进行事件操作.直达不断触发事件的行为结束之后,才进行事件操作.最常见的就是输入框的例子.如下面代码所示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"text"</span>&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="built_in">document</span>.querySelector(<span class="string">'#text'</span>),</span><br><span class="line">        timer = <span class="literal">null</span>,</span><br><span class="line">        currentSearch = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    text.addEventListener(<span class="string">'keyup'</span>, (e) =&gt;&#123;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 声明一个当前所搜的状态变量</span></span><br><span class="line">            currentSearch ＝ <span class="string">'书'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> searchText = e.target.value;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url: <span class="string">`search.qq.com/<span class="subst">$&#123;searchText&#125;</span>`</span>,</span><br><span class="line">                success: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断后台返回的标志与我们存的当前搜索变量是否一致</span></span><br><span class="line">                    <span class="keyword">if</span> (data.search === currentSearch) &#123;</span><br><span class="line">                        <span class="comment">// 渲染展示</span></span><br><span class="line">                        render(data);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// ..</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,<span class="number">250</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码就是一个很常见的一个事件节流的用法.当你按下键盘触发事件时,并不是直接发送AJAX请求.而是使用<code>setTimeout</code>延迟250毫秒.在延迟的过程中如果有新的事件触发.就会重新计算延迟.如此不断的反复.直到两次触发事件的间隔大于250毫秒.才会真正的发送AJAX请求.</p><p>&emsp;&emsp;下面让我们来看看上述的逻辑用RxJS怎样的实现.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line">Rx.Observable.fromEvent(button, <span class="string">'click'</span>)</span><br><span class="line">  .debounceTime(<span class="number">250</span>)</span><br><span class="line">  .subscribe(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $.ajax(&#123;</span><br><span class="line">        url: <span class="string">`search.qq.com/<span class="subst">$&#123;searchText&#125;</span>`</span>,</span><br><span class="line">        success: <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 判断后台返回的标志与我们存的当前搜索变量是否一致</span></span><br><span class="line">          <span class="keyword">if</span> (data.search === currentSearch) &#123;</span><br><span class="line">            <span class="comment">// 渲染展示</span></span><br><span class="line">            render(data);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ..</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面是用RxJS实现的同样的功能.但我们看到其代码精简了许多.上述代码中首先获取到一个<code>button</code>元素.然后使用<code>Rx.Observable.fromEvent</code>创建了一个被观察对象.其对象所监听的是<code>button</code>元素的<code>.click</code>事件.每当<code>button</code>元素的<code>click</code>事件触发时.就会发射一个值出去.这个值途中经过<code>debounceTime</code>操作符,延时了250毫秒.然后再被观察者对象捕获.最终触发其定义的AJAX事件.这就是上述代码中的实现过程.<br>&emsp;&emsp;然而我们看到.虽然上述在定义执行的过程中做了许多的事情,但这些是RxJS在内部帮助我们就做好了的.我们只需要它给我们的API方法就可以实现用几段简单的代码,实现一段复杂的操作.</p><h3 id="Observable-可观察对象"><a href="#Observable-可观察对象" class="headerlink" title="Observable (可观察对象)"></a>Observable (可观察对象)</h3><blockquote><p>Observables 是多个值的惰性推送集合</p></blockquote><p>&emsp;&emsp;Observable是RxJS的核心概念之一.它实际上就是可以被外界观察的一个对象.当本身的状态发生变化时,就会将其变化推送给外界观察它的对象,也就是 <strong>观察者对象</strong>.同时因为<code>Observables 是多个值的惰性推送集合</code>所以只有当使用一个观察者对象去订阅了它之后.它才会同步或异步地返回零到(有可能的)无限多个值.下面是使用RxJS创建一个<code>Observable</code>的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.create(<span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="string">'hi'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面实例创建了一个 Observable，它每隔一秒会向观察者发送字符串 ‘hi’.</p><h3 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer (观察者)"></a>Observer (观察者)</h3><blockquote><p>什么是观察者？ - 观察者是由 Observable 发送的值的消费者。观察者只是一组回调函数的集合，每个回调函数对应一种 Observable 发送的通知类型：next、error 和 complete 。</p></blockquote><p>&emsp;&emsp;简单来说,<code>Observer</code>就是使用<code>Observable</code>发送出来值的一个方法集合.当一个<code>Observable</code>发送出来值之后由<code>Observer</code>来决定如何的去使用它.而使用的方式就是通过回调函数.将<code>Observable</code>发送出来的值作为参数传入其中.让后在内部去使用.同时根据<code>Observable</code>发送出来的值不同.其调用的回调函数也不同.分别有<code>next</code>(下一步),<code>error</code>(报错),<code>complete</code>(结束).下面是使用<code>Observer</code>的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure><blockquote><p>要使用观察者，需要把它提供给 Observable 的 subscribe 方法</p></blockquote><h3 id="Subscription-订阅"><a href="#Subscription-订阅" class="headerlink" title="Subscription (订阅)"></a>Subscription (订阅)</h3><blockquote><p>什么是 Subscription ？ - Subscription 是表示可清理资源的对象，通常是 Observable 的执行。Subscription 有一个重要的方法，即 unsubscribe，它不需要任何参数，只是用来清理由 Subscription 占用的资源。在上一个版本的 RxJS 中，Subscription 叫做 “Disposable” (可清理对象)。</p></blockquote><p>&emsp;&emsp;<code>Subscription</code>(订阅)是使用<code>observable.subscribe()</code>创建一个观察者对象时.所返回的一个对象.它主要就是使用<code>unsubscribe() 函数</code>主动关闭<code>Observer</code>对<code>Observable</code>的监听订阅.其使用方法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observable = Rx.Observable.interval(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> subscription = observable.subscribe(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br><span class="line"><span class="comment">// 稍后：</span></span><br><span class="line"><span class="comment">// 这会取消正在进行中的 Observable 执行</span></span><br><span class="line"><span class="comment">// Observable 执行是通过使用观察者调用 subscribe 方法启动的</span></span><br><span class="line">subscription.unsubscribe();</span><br></pre></td></tr></table></figure><h3 id="Operators-操作符"><a href="#Operators-操作符" class="headerlink" title="Operators (操作符)"></a>Operators (操作符)</h3><blockquote><p>操作符是 Observable 类型上的方法，比如 .map(…)、.filter(…)、.merge(…)，等等。当操作符被调用时，它们不会改变已经存在的 Observable 实例。相反，它们返回一个新的 Observable ，它的 subscription 逻辑基于第一个 Observable 。<br>操作符是函数，它基于当前的 Observable 创建一个新的 Observable。这是一个无副作用的操作：前面的 Observable 保持不变。</p></blockquote><p>&emsp;&emsp;就本质上而言<code>Operators</code>就是一个纯粹的函数.它可以接收一个 Observable 作为输入.并在经过内部的一系列处理后返回一个新的<code>Observable</code>作为输出.流向下一个操作.</p><h3 id="Subject-主体"><a href="#Subject-主体" class="headerlink" title="Subject (主体)"></a>Subject (主体)</h3><blockquote><p>什么是 Subject？ - RxJS Subject 是一种特殊类型的 Observable，它允许将值多播给多个观察者，所以 Subject 是多播的，而普通的 Observables 是单播的(每个已订阅的观察者都拥有 Observable 的独立执行)。<br>Subject 像是 Observalbe，但是可以多播给多个观察者。Subject 还像是 EventEmitters，维护着多个监听器的注册表。</p></blockquote><p>&emsp;&emsp;每一个<code>Subject</code>都同时是一个<code>Observable</code>和<code>Observer</code>.对于<code>Subject</code>你可以使用<code>subscribe</code>方法并指定一个观察者.也可以调用<code>next(v)</code>、<code>error(e)</code> 和 <code>complete()</code>来处理接受道到值.示例如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> Rx.Subject();</span><br><span class="line"></span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerA: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line">subject.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'observerB: '</span> + v)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.next(<span class="number">1</span>);</span><br><span class="line">subject.next(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们为 Subject 添加了两个观察者，然后给 Subject 提供一些值</p><h3 id="Schedulers-调度器"><a href="#Schedulers-调度器" class="headerlink" title="Schedulers (调度器)"></a>Schedulers (调度器)</h3><blockquote><p>什么是调度器？ - 调度器控制着何时启动 subscription 和何时发送通知。它由三部分组成：</p><ul><li>调度器是一种数据结构。 它知道如何根据优先级或其他标准来存储任务和将任务进行排序。</li><li>调度器是执行上下文。 它表示在何时何地执行任务(举例来说，立即的，或另一种回调函数机制(比如 setTimeout 或 process.nextTick)，或动画帧)。</li><li>调度器有一个(虚拟的)时钟。 调度器功能通过它的 getter 方法 now() 提供了“时间”的概念。在具体调度器上安排的任务将严格遵循该时钟所表示的时间。<br>调度器可以让你规定 Observable 在什么样的执行上下文中发送通知给它的观察者。</li></ul></blockquote><p>上面是我最近学习RxJS时一些粗浅的总结,希望对大家有所帮助.如果文中有何不当之处请予以斧正,谢谢.<br><strong>参考资料</strong></p><ul><li><p><a href="http://cn.rx.js.org/manual/overview.html#h11" target="_blank" rel="noopener">RxJS中文手册</a></p></li><li><p><a href="https://www.qcloud.com/community/article/191068?fromSource=gwzcw.107650.107650.107650" target="_blank" rel="noopener">构建流式应用：RxJS 详解</a></p></li></ul><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJS </tag>
            
            <tag> 观察者模式 </tag>
            
            <tag> 迭代模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Angular中的生命周期钩子的理解</title>
      <link href="/2017/07/06/%E5%AF%B9Angular%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2017/07/06/%E5%AF%B9Angular%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是生命周期钩子"><a href="#什么是生命周期钩子" class="headerlink" title="什么是生命周期钩子"></a>什么是生命周期钩子</h2><p>&emsp;&emsp;简单点来说生命周期钩子就是Angular中一个组件从被创建当销毁期间的一些有意义的关键时刻.这些关键时刻在Angular中被Angular核心模块<code>@angular/core</code>暴露出来,赋予了我们在它们发生时采取行动的能力.</p><h2 id="有哪些生命周期钩子"><a href="#有哪些生命周期钩子" class="headerlink" title="有哪些生命周期钩子"></a>有哪些生命周期钩子</h2><p>&emsp;&emsp;Angular中从一个组件的创建到销毁一个有八个生命周期钩子它们,按照先后顺序.它们分别是:</p><ul><li><code>ngOnChanges()</code></li><li><code>ngOnInit()</code></li><li><code>ngDoCheck()</code></li><li><code>ngAfterContentInit()</code></li><li><code>ngAfterContentChecked()</code></li><li><code>ngAfterViewInit()</code></li><li><code>ngAfterViewChecked()</code></li><li><code>ngOnDestroy()</code></li></ul><p>&emsp;&emsp;其中:<code>ngOnInit()</code>、<code>ngAfterContentInit()</code>、<code>ngAfterViewInit()</code>和<code>ngOnDestroy()</code>在一个组件的生命周期中只会被调用一次,其它的都有可能会被多次调用.下面,就让我们来详细解列一下这些生命周期钩子.</p><h3 id="ngOnChanges"><a href="#ngOnChanges" class="headerlink" title="ngOnChanges()"></a>ngOnChanges()</h3><blockquote><ul><li>当Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的SimpleChanges对象</li><li>当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit()之前。</li></ul></blockquote><p>&emsp;&emsp;<code>ngOnChanges()</code>生命周期的调用与一个组件中的输入属性有关.</p><p>&emsp;&emsp;当在一个组件中使用<code>@Input()</code>定义了一个输入属性时.只要这个输入属性的值发生了改变.就会触发<code>ngOnChanges()</code>生命周期钩子.这个生命周期钩子被调用时会传入一个<code>SimpleChanges</code>对象,这个对象中包含了输入属性当前值和上一值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Input()</span><br><span class="line">public name: string;</span><br><span class="line"></span><br><span class="line">ngOnChanges(changes: SimpleChanges): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(changes); <span class="comment">// name:SimpleChange &#123;previousValue: "a", currentValue: "ab", firstChange: false&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面是我定义了一个输入属性<code>name</code>并将从<code>a</code>它改为<code>ab</code>之后的打印结果,可能你还注意到了打印的结果中还有一个<code>firstChange</code>属性.它是一个Booleans,表明你是否是第一次改变.</p><p>&emsp;&emsp; <strong>同时,还有一点需要注意:</strong> 你的输入属性定义为你引用类型和基本类型的时候其表现结果是不同的.当你的输入属性是基本类型时.你的每一次改变都会触发<code>ngOnChanges()</code>生命周期钩子,而当你的输入属性是引用类型时,你改变你引用类型 <strong><em>当中</em></strong> 的属性时,并不会触发<code>ngOnChanges()</code>生命周期钩子.只有当你将你引用类型数据的指针指向另一块内存地址的时候才会触发<code>ngOnChanges()</code>生命周期钩子.</p><h3 id="ngOnInit"><a href="#ngOnInit" class="headerlink" title="ngOnInit()"></a>ngOnInit()</h3><blockquote><ul><li>在Angular第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。</li><li>在第一轮ngOnChanges()完成之后调用，只调用一次。</li></ul></blockquote><p>&emsp;&emsp;<code>ngOnInit()</code>是一个组件的生命周期中一定存在的一个钩子.它在一个组件被初始化的时候被调用.在这个期间,你可以执行一些相应的数据绑定操作.</p><h3 id="ngDoCheck"><a href="#ngDoCheck" class="headerlink" title="ngDoCheck()"></a>ngDoCheck()</h3><blockquote><ul><li>检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。</li><li>在每个Angular变更检测周期中调用，ngOnChanges()和ngOnInit()之后。</li></ul></blockquote><p>&emsp;&emsp;<code>ngDoCheck()</code>是Angular中的变更检测机制.它由<code>zone.js</code>来实现的.其行为是只要你的Angular中的某个组件发生异步事件.就会检查整个组件树,以保证组件属性的变化或页面的变化是同步的.所以<code>ngDoCheck()</code>的触发相当频繁的.并且是我们无法预料到的.也许我们在页面上的一个无意识操作,就会触发几个甚至几十个的<code>ngDoCheck()</code>生命周期钩子.<br>&emsp;&emsp;所以我们在使用<code>ngDoCheck()</code>生命周期钩子的时候一定要加上判断.以避免无用的触发干扰我们.</p><h3 id="ngAfterContentInit"><a href="#ngAfterContentInit" class="headerlink" title="ngAfterContentInit()"></a>ngAfterContentInit()</h3><blockquote><ul><li>当把内容投影进组件之后调用。</li><li>第一次ngDoCheck()之后调用，只调用一次。</li><li>只适用于组件。</li></ul></blockquote><p>&emsp;&emsp;当父组件向子组件投影内容的时.在子组件内会初始化父组件的投影内容,此时会调用<code>ngAfterContentInit()</code>生命周期钩子.在整个组件生命周期中<code>ngAfterContentInit()</code>生命周期钩子只会调用一次.如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;app-child&gt;</span><br><span class="line">  &lt;p&gt;我是父组件向子组件的投影内容&lt;/&gt;</span><br><span class="line">&lt;/app-child&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 子组件 ChildComponent</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  //接受父组件的投影内容</span><br><span class="line">  &lt;ng-content&gt;&lt;/ng-content&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="ngAfterContentChecked"><a href="#ngAfterContentChecked" class="headerlink" title="ngAfterContentChecked()"></a>ngAfterContentChecked()</h3><blockquote><ul><li>每次完成被投影组件内容的变更检测之后调用。</li><li>ngAfterContentInit()和每次ngDoCheck()之后调用</li><li>只适合组件。</li></ul></blockquote><p>&emsp;&emsp;当父组件向子组件的投影内容发生改变时会调用<code>ngAfterContentChecked()</code>生命周期钩子.它与<code>ngDoCheck()</code>类似.当投影内容发生改变时,就会执行变更检查机制.同时调用<code>ngAfterContentChecked()</code>生命周期钩子.此外.还有一点:当父组件和子组件都有投影内容时,会先执行父组件的生命周期钩子.它与下面要说的<code>ngAfterViewInit()</code>和<code>ngAfterViewChecked()</code>相反.</p><h3 id="ngAfterViewInit"><a href="#ngAfterViewInit" class="headerlink" title="ngAfterViewInit()"></a>ngAfterViewInit()</h3><blockquote><ul><li>初始化完组件视图及其子视图之后调用。</li><li>第一次ngAfterContentChecked()之后调用，只调用一次。</li><li>只适合组件。</li></ul></blockquote><p>&emsp;&emsp;当其组件本身和所有的子组件渲染完成,已经呈现在页面上时,调用<code>ngAfterViewInit()</code>生命周期钩子.在整个组件生命周期中<code>ngAfterViewInit()</code>生命周期钩子只会调用一次.</p><h3 id="ngAfterViewChecked"><a href="#ngAfterViewChecked" class="headerlink" title="ngAfterViewChecked()"></a>ngAfterViewChecked()</h3><blockquote><ul><li>每次做完组件视图和子视图的变更检测之后调用。</li><li>ngAfterViewInit()和每次ngAfterContentChecked()之后调用。</li><li>只适合组件。</li></ul></blockquote><p>&emsp;&emsp;当组件及其子组件的视图发生改变时,执行完变更检查机制后调用.当父组件和子组件都发生视图变化时,会先执行子组件的生命周期钩子.</p><p>&emsp;&emsp;<strong>注意:</strong> 这里所说的视图发生改变不一定是真正页面上的变化.只是Angular种所认为的视图变化.因为Angular本身并不能察觉到页面上显示的视图.所以在Angular认为,只要你在后台定义的属性发生了改变,就是视图有了变化.从而就会调用<code>ngAfterViewChecked()</code>生命周期钩子.</p><h3 id="ngOnDestroy"><a href="#ngOnDestroy" class="headerlink" title="ngOnDestroy"></a>ngOnDestroy</h3><blockquote><ul><li>当Angular每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。</li><li>在Angular销毁指令/组件之前调用。</li></ul></blockquote><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Angular </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端跨域之CORS</title>
      <link href="/2017/06/21/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E4%B9%8BCORS/"/>
      <url>/2017/06/21/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E4%B9%8BCORS/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;在前端开发中出于种种原因,总会有需要访问其它域名数据的时候.比如说,因为某项业务你需要调用一下第三方的一个接口.或者说你需要与其他域名的网站交互一下数据等等.不一而足.但是,与此同时我们也知道.浏览器在出于安全方面的考虑,有一个同源策略.只要是不同域名,不同端口,不同协议之间的通讯都会被浏览器阻止.而在这个情况下,跨域这个概念也就油然而生了.</p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><blockquote><p>跨域一词从字面意思看，就是跨域名嘛，但实际上跨域的范围绝对不止那么狭隘。具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。之所以会产生跨域这个问题呢，其实也很容易想明白，要是随便引用外部文件，不同标签下的页面引用类似的彼此的文件，浏览器很容易懵逼的，安全也得不到保障了就。什么事，都是安全第一嘛。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。下面是具体的跨域情况详解：</p></blockquote><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a></td><td></td><td></td></tr><tr><td><a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>同一域名下</td><td>允许</td></tr><tr><td><a href="http://www.a.com/lab/a.js" target="_blank" rel="noopener">http://www.a.com/lab/a.js</a></td><td></td><td></td></tr><tr><td><a href="http://www.a.com/script/b.js" target="_blank" rel="noopener">http://www.a.com/script/b.js</a></td><td>同一域名下不同文件夹</td><td>允许</td></tr><tr><td><a href="http://www.a.com:8000/a.js" target="_blank" rel="noopener">http://www.a.com:8000/a.js</a></td><td></td><td></td></tr><tr><td><a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a></td><td></td><td></td></tr><tr><td><a href="https://www.a.com/b.js" target="_blank" rel="noopener">https://www.a.com/b.js</a></td><td>同一域名，</td><td>不同协议 不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a></td><td></td><td></td></tr><tr><td><a href="http://70.32.92.74/b.js" target="_blank" rel="noopener">http://70.32.92.74/b.js</a></td><td>域名和域名对应ip</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a></td><td></td><td></td></tr><tr><td><a href="http://script.a.com/b.js" target="_blank" rel="noopener">http://script.a.com/b.js</a></td><td>主域相同，子域不同</td><td>不允许（cookie这种情况下也不允许访问）</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="noopener">http://www.a.com/a.js</a></td><td></td><td></td></tr><tr><td><a href="http://a.com/b.js" target="_blank" rel="noopener">http://a.com/b.js</a></td><td>同一域名，不同二级域名（同上）</td><td>不允许（cookie这种情况下也不允许访问）</td></tr><tr><td><a href="http://www.cnblogs.com/a.js" target="_blank" rel="noopener">http://www.cnblogs.com/a.js</a></td><td></td><td></td></tr><tr><td><a href="http://www.a.com/b.js" target="_blank" rel="noopener">http://www.a.com/b.js</a></td><td>不同域名</td><td>不允许</td></tr></tbody></table><p>所以简单来说,跨域就是为了避开浏览器的同源策略而使用的一种手段.</p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>&emsp;&emsp;就目前而言,常见的跨域方式有三种,一种是服务器代理,一种是JSONP,还有一种就是我们今天要讲的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;```CORS```也被称为跨域资源共享.他是HTML5推出的对于跨域问题的一个解决方案.也是最正统的解决方案.它几乎不需要我们在配置什么,与普通的```XMLHttorequest```请求一样.浏览器在我们发送请求的时候会自动的为我们配置好.只要在服务端支持```CORS```就可以正常的跨域访问.</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;在```CORS```之前.所使用的服务器代理和JSONP都是不是标准所支持的.而是我们充满智慧的程序员们另辟蹊径所想出来的解决方案.</span><br><span class="line"></span><br><span class="line">### 什么是CORS</span><br><span class="line">&gt; CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出```XMLHttpRequest```请求，从而克服了AJAX只能同源使用的限制。</span><br><span class="line"></span><br><span class="line">### CORS简介</span><br><span class="line">&gt; CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。  </span><br><span class="line">整个```CORS```通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。  </span><br><span class="line">因此，实现```CORS```通信的关键是服务器。只要服务器实现了```CORS```接口，就可以跨源通信。</span><br><span class="line"></span><br><span class="line">### 两种请求</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;在支持```CORS```的浏览器中,```CORS```请求分为两种.</span><br><span class="line"></span><br><span class="line">* 一种是不会触发```CORS```预检的简单请求:</span><br><span class="line">&gt; 这些跨域请求与浏览器发出的其他跨域请求并无二致。如果服务器未返回正确的响应首部，则请求方不会收到任何数据。因此，那些不允许跨域请求的网站无需为这一新的 HTTP 访问控制特性担心。</span><br><span class="line"></span><br><span class="line">只要同时满足以下两大条件，就属于简单请求</span><br><span class="line"></span><br><span class="line">```http</span><br><span class="line">1. 请求方法是以下三种方法之一：</span><br><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br><span class="line"></span><br><span class="line">2. HTTP的头信息不超出以下几种字段：</span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</span><br></pre></td></tr></table></figure></p><ul><li>一种是会触发<code>CORS</code>预检的预检请求<blockquote><p>与简单请求不同，“需预检的请求”要求必须首先使用 OPTIONS   方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p></blockquote></li></ul><p>只要请求满足下述任一条件时，即为预检请求</p><ul><li>使用了下面任一 HTTP 方法：<ul><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ul></li><li>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type (but note the additional requirements below)</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li>Content-Type 的值不属于下列之一:<ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li></ul><h3 id="服务器设置"><a href="#服务器设置" class="headerlink" title="服务器设置"></a>服务器设置</h3><ul><li>Access-Control-Allow-Origin（必含） – 允许的域名，只能填通配符或者单域名</li><li>Access-Control-Allow-Methods（必含） – 这允许跨域请求的http方法（常见有POST、GET、OPTIONS）</li><li>Access-Control-Allow-Headers（当预请求中包含Access-Control-Request-Headers时必须包含） – 这是对预请求当中Access-Control-Request-Headers的回复，和上面一样是以逗号分隔的列表，可以返回所有支持的头部。</li><li>Access-Control-Allow-Credentials（可选） – 该项标志着请求当中是否包含cookies信息，只有一个可选值：true（必为小写）。如果不包含cookies，请略去该项，而不是填写false。这一项与XmlHttpRequest2对象当中的withCredentials属性应保持一致，即withCredentials为true时该项也为true；withCredentials为false时，省略该项不写。反之则导致请求失败。</li><li>Access-Control-Max-Age（可选） – 以秒为单位的缓存时间。预请求的的发送并非免费午餐，允许时应当尽可能缓存。</li></ul><h3 id="CORS的优势"><a href="#CORS的优势" class="headerlink" title="CORS的优势"></a>CORS的优势</h3><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。<br>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p><h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><p><img src="http://img.blog.csdn.net/20170719223605267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYyNzY1Mjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>参考资料</strong></p><ul><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS）</a></li></ul><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AJAX </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对ES6Generator函数的理解</title>
      <link href="/2017/05/28/%E5%AF%B9ES6Generator%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2017/05/28/%E5%AF%B9ES6Generator%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Generator函数"><a href="#什么是Generator函数" class="headerlink" title="什么是Generator函数"></a>什么是Generator函数</h2><blockquote><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p></blockquote><p>&emsp;&emsp;简单说Generator函数是ES6新推出的一种语法,其目的是为了给JS的异步式编程提供一种更好的解决方案.在传统的回调函数异步式编程中,存在的一个最大的问题就是,如果要进行大量的异步式操作时,那么其代码将会一个嵌套者一个.这样一旦嵌套过多,将会造成代码难以理解.并且其代码之间高度耦合.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>("./data1.json",function(data1)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data1)</span><br><span class="line">  $.<span class="keyword">get</span>("./data2.json",function(data2)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data2)</span><br><span class="line">    $.<span class="keyword">get</span>("./data3.json",function(data3)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data3);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Generator函数的基本概念"><a href="#Generator函数的基本概念" class="headerlink" title="Generator函数的基本概念"></a>Generator函数的基本概念</h2><blockquote><p>&emsp;&emsp;Generator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br>&emsp;&emsp;执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。<br>&emsp;&emsp;形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。<br>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p></blockquote><p>上面是<a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a>所写的<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a>中对于Generator函数概念的描述.</p><p>&emsp;&emsp;对此我的理解是Generator函数在形式上没有什么区别.只是在定义的时候需要在<figure class="highlight plain"><figcaption><span>```*```符号.其次,在执行的时候,Generator函数内部如果没有```yield```关键字时,那就一个有着依次暂停的普通函数.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```JavaScript</span><br><span class="line">function * fn(str) &#123;</span><br><span class="line">  console.log(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let f = fn(&quot;aaaa&quot;);</span><br><span class="line"></span><br><span class="line">console.log(f) //&#123;[[GeneratorStatus]]: &quot;suspended&quot;&#125;</span><br><span class="line"></span><br><span class="line">f.next(); // aaaa</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;从是上代码中可以看到,代码中首先定义了一个Generator函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">并将函数的返回值传给变量```f```.再打印```f```.最后用```f```调用```nex()```方法.   </span><br><span class="line">&amp;emsp;&amp;emsp;而在执行了上述代码后可以看到.函数在第一次调用时并没有执行内部的代码,而是返回了一个对象,在使用这个对象调用了```next```方法之后才真正的执行了函数内部的代码.这就是普通的Generator函数在内部没有```yield```关键字时的执行过程.除了有一次暂停外,就结果而言,它与普通函数并没有什么不同.</span><br><span class="line">&amp;emsp;&amp;emsp;</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;但是当```Generator```函数中使用了```yield```关键字后.代码的执行就有了改变.</span><br><span class="line"></span><br><span class="line">```JavaScript</span><br><span class="line">function * fn() &#123;</span><br><span class="line">  console.log(&quot;a&quot;);</span><br><span class="line">  let a = &quot;abc&quot;;</span><br><span class="line">  yield a;</span><br><span class="line">  </span><br><span class="line">  console.log(&quot;b&quot;);</span><br><span class="line">  let b = &quot;123&quot;;</span><br><span class="line">  yield b;</span><br><span class="line"></span><br><span class="line">  let c = &quot;张三&quot;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let f = fn();</span><br><span class="line"></span><br><span class="line">console.log(f.next()) // a</span><br><span class="line">// &#123;value: &quot;abc&quot;, done: false&#125;</span><br><span class="line">console.log(f.next()) // b</span><br><span class="line">// &#123;value: &quot;123&quot;, done: false&#125;</span><br><span class="line">console.log(f.next())</span><br><span class="line">// &#123;value: undefined, done: true&#125;</span><br><span class="line">console.log(f.next())</span><br><span class="line">// &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在上面的代码中,我们定义了一个<code>Generator</code>函数,并在函数的内部定义了两个<code>yield</code>关键字,然后执行这个函数,并在相应的地方打印出值.在打印的结果中可以看出.<code>yield</code>关键字在函数运行中会将函数暂停.这个时候只有再次调用<code>next()</code>方法才能继续执行<code>Generator</code>函数.同时<code>yield</code>还将会返回一个对象,这个对象中包含两个属性.一个是<code>value</code>,一个是<code>done</code>.其中<code>value</code>值是对应的<code>yield</code>关键字后面所跟的值.而<code>done</code>则表示所属的<code>Generator</code>函数后面是否还有需要执行的代码.</p><p>&emsp;&emsp;上面是我个人对<code>Generator</code>函数的运行机制的一个理解,说的可能有点乱.没有表述清楚.所以我在呢下面引用了<a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a>在<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">ECMAScript 6 入门</a>中对<code>Generator</code>函数的描述.希望对大家有所帮助</p><blockquote><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p></blockquote><blockquote><p>&emsp;&emsp;由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。<br>遍历器对象的next方法的运行逻辑如下。<br>（1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。<br>（2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。<br>（3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。<br>（4）如果该函数没有return语句，则返回的对象的value属性值为undefined。<br>&emsp;&emsp;需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p></blockquote><h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><p>PC端:</p><p><img src="http://img.blog.csdn.net/20170718014018005?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYyNzY1Mjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>移动端:<br><img src="http://img.blog.csdn.net/20170718014308066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYyNzY1Mjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>参考文档:</strong><a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a> - <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></p><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node那些事之模块化</title>
      <link href="/2017/05/25/Node%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2017/05/25/Node%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是模块化开发-及模块化开发的好处"><a href="#什么是模块化开发-及模块化开发的好处" class="headerlink" title="什么是模块化开发,及模块化开发的好处"></a>什么是模块化开发,及模块化开发的好处</h2><ul><li><strong>什么是模块化开发:</strong> 把一些功能类似的代码,封装到一个单独的文件中去,这些单独抽离出来的代码,就能够提供各种各样好用的功能.这种通过代码功能分割文件的方式就叫做模块化开发.</li><li><strong>好处:</strong> 保证了每个文件的功能(职能)单一.需要什么特定的功能,就直接调用某一个特定的模块.这样对将来程序开发和维护都有好处</li></ul><h2 id="Node中如何实现模块化开发"><a href="#Node中如何实现模块化开发" class="headerlink" title="Node中如何实现模块化开发"></a>Node中如何实现模块化开发</h2><p>在Node中主要通过三个东西实现模块化开发:</p><ul><li><strong>module:</strong> 表示一个模块,在Node中最常见的模块就是一个一个的JS文件.</li><li><strong>require:</strong> 作用是加载其他模块用的.在一个JS文件中如果想要引用其他JS文件的成员,就需要使用<code>require</code>.</li><li><strong>exports:</strong> 在Node的模块中,如果要这个模块向外暴露一些成员,以供其它JS模块使用,那么就要使用<code>exports</code></li></ul><p>Node中的模块化主要是为了解决JS文件之间的相互依赖关系</p><h2 id="Node中模块的分类"><a href="#Node中模块的分类" class="headerlink" title="Node中模块的分类"></a>Node中模块的分类</h2><p>Node有三部分组成:ECMAScript + 核心API + 第三方包</p><h3 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h3><ul><li>什么是核心API: 由Node官方将一些常用的功能模块编译成二进制的执行文件,然后集成到Node的安装包中.在我们安装完Node之后,也同时安装了这些功能模块.</li><li>如何使用核心模块:  使用require(“核心模块名称”)如下例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> XXX = <span class="built_in">require</span>(<span class="string">"XXX"</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><ul><li><p>什么是第三方模块: 除了官方提供的核心模块之外,我们在日常开发中也许还有一些使用频率很高的功能代码.而这些功能就被一些厉害的团队、个人、公司打包成可复用的模块.并通过NPM官网托管出去,供其他人下载使用.</p></li><li><p>如何使用第三方模块:</p><ol><li>先使用npm下载这个模块.</li><li>使用require导入你所下载的第三方模块.你导入模块的名字就是你安装时的名字.</li><li>通过查阅官方文档,使用你所下载的第三方模块</li></ol></li><li><p><em>注意:*</em>无论是核心模块还是第三方模块,都是通过 <strong><em>标识符名称</em></strong> 来引用这个模块的.</p></li></ul><h3 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h3><ul><li>什么是用户模块: 自己所写的JS文件,统统属于用户模块</li><li>用户模块向外导出成员的两种方式:<ol><li>使用global这个全局对象,将你想要导出的成员挂载到这个对象上面.但是这种方法有两个缺陷.<ul><li>会造成全局变量污染</li><li>不知道所引用的成员是谁导出的.<br>所以一般情况下我们使用下面这种方式.</li></ul></li><li>使用exports来导出需要暴露的成员</li></ol></li></ul><h2 id="exports和module-exports"><a href="#exports和module-exports" class="headerlink" title="exports和module.exports"></a>exports和module.exports</h2><ol><li>通过module.exports可以使用 <code>.</code> 的形式追加属性,也可以使用 <code>=</code> 直接赋值的形式导出成员</li><li>exports只能通过 <code>.</code> 的形式追加属性,不能使用 <code>=</code> 直接赋值的形式</li><li>在一个module中,最终向外暴露的成员,以<code>module.exports</code>指向的对象为准.</li><li>在一个module中,不要混合使用<code>module.exports</code>和<code>exports</code>.</li></ol><h2 id="Node中的模块加载规则"><a href="#Node中的模块加载规则" class="headerlink" title="Node中的模块加载规则"></a>Node中的模块加载规则</h2><p><strong>优先从缓存中加载</strong></p><ul><li><p>加载核心模块: 优先从缓存中加载,如果缓存中没有再去执行加载核心模块</p></li><li><p>加载自己的模块: 优先从缓存中加载,如果缓存中没有,再去执行加载自己的模块.<br>用户模块的查找规则:<br>不过不写后缀名,则先严格按照给定的文件名去查找模块并加载.如果找不到,则按照一定的规则顺序去查找加载带后缀名的同名文件.如下例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index -&gt; index.js -&gt; index.json -&gt; index.node</span><br></pre></td></tr></table></figure></li><li><p>第三方的模块查找规则:</p><ol><li>首先查看项目的跟目录下有没有<code>node_modules</code>这个文件夹.</li><li>查找<code>node_modules</code>文件夹中有没和第三方模块名称一致的文件夹.</li><li>在模块对应的文件夹中,查找有没有<code>package.json</code>这个文件</li><li>在<code>package.json</code>文件中查找有没有<code>main</code>属性.</li><li>如果有<code>main</code>属性,并且<code>main</code>属性指向的路径存在,那么就尝试加载这个路径指定的文件</li><li>如果<code>package.json</code>文件中,没有<code>main</code>属性,或者<code>main</code>属性指向的路径不存在,或者干脆就没有<code>package.json</code>文件.那么,就会尝试加载模块根目录中的<code>index</code>相关文件:<code>index.js -&gt; index.json -&gt; index.node</code></li><li>如果在<code>node_modules</code>文件中找不到对应的模块文件夹,或者在项目根目录中就没有<code>node_modules</code>这个文件夹.则会向上一层的文件夹中查找,查找规则同上.</li><li>如果上一层文件夹得目录中也没有找到,则再向上一层文件夹中去找,直到找到当前项目所在的盘符根目录为止.</li><li>如果找到盘符根目录还没有找到,则报错:<code>cannot find module ***</code></li></ol></li></ul><h2 id="关于模块化"><a href="#关于模块化" class="headerlink" title="关于模块化"></a>关于模块化</h2><ul><li>Node中的模块化基于<code>common.js</code>,其特点是有所的依赖项同步加载.</li><li><code>common.js</code>由于是一个同步加载规范,所以不适合浏览端使用.于是浏览端有了异步模块加载机制AMD规范.</li><li>在ES6中已推出了语言规格上的模块化方案.</li></ul><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Node那些事系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JavaScript 基本型数据和引用型数据的区别。</title>
      <link href="/2017/04/22/%E5%85%B3%E4%BA%8EJavaScript%20%E5%9F%BA%E6%9C%AC%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%92%8C%E5%BC%95%E7%94%A8%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/04/22/%E5%85%B3%E4%BA%8EJavaScript%20%E5%9F%BA%E6%9C%AC%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%92%8C%E5%BC%95%E7%94%A8%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>JavaScript中有七种数据类型,分别是:<br>六个基本类型 : Number, String,Null, Boolean, Undefined 以及在ES6新推出的<strong><em>Symbols</em></strong>和引用型数据: Object(对象)。</p><p><strong>注意:</strong> Array 、Function、Date….也都是属于Object（对象）。因为它们在原型链上都会有一个内部指针，指向Object.prototype。</p><h3 id="基本数据类型的特点："><a href="#基本数据类型的特点：" class="headerlink" title="基本数据类型的特点："></a>基本数据类型的特点：</h3><ol><li>基本数据类型被保存在栈内存中并据有固定的大小：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"String"</span>;</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;如上声明了一个变量str,并将字符串”String”复制给它.此时在内存中就是下图所示<br><img src="http://img.blog.csdn.net/20170410134847480?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYyNzY1Mjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="基本型数据内存储存结构"><br>此时在栈内存中变量str所对应的是”String”这个值，而值”String”在内存中所占用的大小是固定的。<br>也许你会有下面的这个疑问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"String"</span>;</span><br><span class="line">str = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure><p>这样变量str的大小不就改变了吗？<br>&emsp;&emsp;是的，这样str的大小的确得到了改变。但是也只是str的大小得到了改变。我们要明确一点：<strong>我们所说的基本数据类型并不是变量str，而是“String”。</strong>变量str只是在“String”被赋值给它之后。指向了”String”这个值。而这个指向在JavaScript中是可以任意更改的。就如在上面的代码中在将变量str声明赋值为”String”之后。又将值“abc”，赋值给了变量str。此时根据JavaScript的规则。对同一变量进行赋值时，后一条语句将覆盖前一条语句。所以此时变量str就将所指向的值改为了”abc”。注意：<strong>这里是将所指向的值改变了，并不是”String”这个基本数据类型的值改变。</strong></p><ol start="2"><li>基本数据类型不可以添加属性和方法但可以调用属性和方法。<br>如下代码所示：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"String"</span>;</span><br><span class="line">str.a = <span class="number">10</span>;</span><br><span class="line">str.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.a);<span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(str.b);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;在上面代码中首先定义了一个基本类型变量str，然后为其设置属性和方法，最后将其打印出来。而得出的结果都是undefined。由此可以说明<strong>基本数据类型不可以添加属性和方法</strong>。</p><p>然后再看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"String"</span>;</span><br><span class="line"><span class="keyword">var</span> leh = str.length;</span><br><span class="line"><span class="keyword">var</span> STR = str.toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(leh);<span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(STR);<span class="comment">//STRING</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面代码中一个基本类型变量str调用了toUpperCase()方法和length属性，并成功返回结果。由此可以说明<strong>基本数据类型可以调用属性和方法</strong>。<br>&emsp;&emsp;而之所以会出现这一现象。是因为基本数据类型本身是不可以调用属性和方法。但是当你尝试去用基本数据类型调用属性和方法时，JavaScript会智能的将其创建一个包装类型对象。并用这个包装类型对象去调用你想要调用的属性和方法。并在调用完成之后立即这个包装类型对象销毁。</p><ol start="3"><li>基本数据类型的操作是对值的操作。</li></ol><ul><li>使用基本数据类型的变量对一个新的变量进行赋值。就是将变量的值复制出一个副本，将这个副本赋值给新的变量。所以两个变量之间除了值相等之外没有任何关系。对其中一个变量的操作，并不会影响到另一个变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"String"</span>;</span><br><span class="line"><span class="keyword">var</span> str1 = str；</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//String</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//String</span></span><br><span class="line">str1 = <span class="string">"abc"</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//String</span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">//abc</span></span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;在上面代码中将变量str赋值给变量str1，此时str与str1的值都是”String”。然后将变量str1的值修改”abc”,这时候变量str的值还是为”String”。而变量str1的值为”abc”。</p><ul><li>两个基本数据类型之间的比较是值与值比较<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> str1 =<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str === str1);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p>上面代码中两个相同空字符串全等于比较。返回结果为true.</p><h3 id="引用型数据的特点："><a href="#引用型数据的特点：" class="headerlink" title="引用型数据的特点："></a>引用型数据的特点：</h3><blockquote><p>在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管 ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p></blockquote><p>JavaScript高级程序设计（第3版）</p><p>1.引用型数据的指针被保存在栈内存中，其具体的值被保存在堆内存中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obiect();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上声明了一个变量obj,并将字符串”String”复制给它.此时在内存中就是下图所示<br><img src="http://img.blog.csdn.net/20170410170033476?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYyNzY1Mjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="引用型数据内存储存结构"><br>在JavaScript中创建一个对象并将其赋值给一个变量时。其赋值的并不是这个对象的本身，而是指向这个对象的一个指针。</p><ol start="2"><li><blockquote><p>当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象     ——图灵社区“壮壮的前端之路”</p></blockquote></li></ol><p>因为这个特性使得引用型数据有了如下行为的实现：</p><ul><li>当将一个引用类型的变量赋值给另一个新变量的之后。在新变量上的操作将会影响到旧的变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> object();</span><br><span class="line"><span class="keyword">var</span> obj1 = obj;</span><br><span class="line">obj1.a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);<span class="comment">//10</span></span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;在上面的代码中，首先讲一个空对象赋值给变量obj，然后再将变量obj赋值给新变量obj1。在给新变量obj1添加一个属性a并赋值为10，最后打印出变量obj的属性a的值，给出结果10。因为变量obj赋值给变量obj1的是指向空对象的指针，而不是空对象本身。所以此时空对象依然只有一个，但有了两个对它进行操作的入口。</p><ul><li>两个引用型变量之间的对比，比较的不是具体的值。而是两者指向引用型数据的指针是否一样。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span> : <span class="string">"iwen"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span> : <span class="string">"iwen&#125;;</span></span><br><span class="line"><span class="string">console.log(obj === obj1);//false;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码中定义了两个变量obj 和 obj1 ，并都将其初始化为对象 {name : “iwen”}。然后比较两个值是否相等。结果返回false。这是因为虽然两者的值是一样，但确实两个不同的对象，所以两个变量的内部指针并不相同。故返回false。</p><ol start="3"><li>引用型数据可以动态的更新大小</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);<span class="comment">//1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的代码中，首先定义变量arr为引用型数据-Array(数组)。并添加一条数值型数据 –1。此时arr的长度为1，然后再为arr动态添加一条数据–22。此时在打印arr的长度则为2。其大小以自动得到更新。</p><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 新特性之Native Variables、Feature Queries、Grid Layout</title>
      <link href="/2017/04/16/CSS%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Native%20Variables%E3%80%81%20Feature%20Queries%E3%80%81Grid%20Layout/"/>
      <url>/2017/04/16/CSS%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Native%20Variables%E3%80%81%20Feature%20Queries%E3%80%81Grid%20Layout/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;前端的发展真的是日新月异,在2017年,虽然CSS4依然在草案当中尚未发布,但是,CSS依然新增了许多新的特性.其中,Native Variables(本地变量)、Feature Queries（特征查询）、Grid Layout（栅格布局）这三个特性是最然我感到激动,因为使用它们,可以很大程度上增强你的开发效率和用户体验.下面就让我来一一介绍他们吧.</p><h2 id="Native-Variables-本地变量"><a href="#Native-Variables-本地变量" class="headerlink" title="Native Variables(本地变量)"></a>Native Variables(本地变量)</h2><p><strong><em>CSS Native Variables 是由CSS开发人员在编写CSS时按一定规则所自定义的一个实体字符,其作用为包含在整个CSS文件当中所重复使用的特定值.</em></strong></p><blockquote><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>&emsp;&emsp;在构建大型站点时，作者通常会面对可维护性的挑战。在这些网页中， 所使用的 CSS 的数量是非常庞大的，并且在许多场合大量的信息会重复使用。例如，在网页中维护一个配色方案，意味着一些颜色在CSS文件中多次出现，并被重复使用。当你修改配色方案时，不论是调整某个颜色或完全修改整个配色，都会成为一个复杂的问题，不容出错，而单纯查找替换是远远不够的。<br>&emsp;&emsp;如果使用了 CSS 框架，这种情况会变得尤其糟糕，此时如果要修改颜色，则需要对框架本身进行修改。在这些场合使用 LESS 或 Sass 类似的预处理器是非常有帮助的，但是这种通过添加额外步骤的方式，可能会增加系统的复杂性。CSS变量为我们带来一些预处理器的便利，并且不需要额外的编译。<br>&emsp;&emsp;这些变量的第二个优势就是名称本身就包含了语义的信息。CSS 文件变得易读和理解。main-text-color比文档中的#00ff00更容易理解，特别是同样的颜色出现在不同的文件中的时候。</p></blockquote><blockquote><h3 id="CSS变量能帮助我们干什么"><a href="#CSS变量能帮助我们干什么" class="headerlink" title="CSS变量能帮助我们干什么"></a>CSS变量能帮助我们干什么</h3><p>&emsp;&emsp;在一些命令式编程语言中，像Java、C++亦或是JavaScript，通过变量我们能够跟踪某些状态。变量是一种符号，关联着一个特定的值，变量的值能随着时间的推移而改变。<br>&emsp;&emsp;在像CSS这种声明式语言中，随着时间而改变的值并不存在，也就没有所谓变量的概念了。<br>&emsp;&emsp;CSS 引入了一种层级变量的概念，从而能够从容应对可维护性的挑战。这就会使得在整个 CSS tree 中都可以象征性的引用一个变量。</p></blockquote><ol><li><p>基本语法:</p><ul><li><p>声明一个变量:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line"><span class="attribute">--main-bg-color</span>: brown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上一个选择器的声明中,使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;事实上,这种变量的声明方与你直接使用```width```、```color```这些常规的属性并没有什么不同,只是需要加上```--```的前缀,并且其属性名是自定义的.所以 ***CSS变量也被称为CSS自定义属性***.</span><br><span class="line"></span><br><span class="line">***注意: 在之前的标准中，自定义属性以```var-```作为前缀，后来才改成``--``前缀.***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 使用一个变量</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">element &#123;</span><br><span class="line">background-color: var(--main-bg-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在声明了一个变量之后,想要使用它,只需要用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***注意: 在之前的标准中，自定义属性以```var-```作为前缀，后来才改成``--``前缀.***</span><br><span class="line"></span><br><span class="line">* 变量的特性</span><br><span class="line"></span><br><span class="line">    1. 变量值只能用作属性值，不能用作属性名</span><br><span class="line"></span><br><span class="line">    2. 如果变量值是一个字符串，可以与其他字符串拼接。</span><br><span class="line">    ```css</span><br><span class="line">    element &#123;</span><br><span class="line">        --a : &quot;hello&quot;;</span><br><span class="line">        --b : var(--a)&quot; world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    element::after &#123;</span><br><span class="line">        /* 等同 content: hello world */</span><br><span class="line">        content: var(--b);</span><br><span class="line">        display:block;</span><br><span class="line">        width:100%;</span><br><span class="line">        height:100%;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>如果变量值是数值,不能与数值单位直接连用,必须使用calc()函数,将它们连接</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">    <span class="attribute">--a </span>: <span class="number">200</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">var</span>(--a)<span class="built_in">px</span>;<span class="comment">/*无效*/</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(var(--a) * <span class="number">1px</span>);<span class="comment">/*有效*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果变量值带有单位，就不能写成字符串。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">    <span class="comment">/*无效写法*/</span></span><br><span class="line">    <span class="attribute">--a </span>: <span class="string">"20px"</span>;</span><br><span class="line">    <span class="attribute">font-size </span>: <span class="built_in">var</span>(--a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">    <span class="comment">/*正确写法*/</span></span><br><span class="line">    <span class="attribute">--a </span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size </span>: <span class="built_in">var</span>(--a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同一个 CSS 变量,可以在多个选择器内声明.读取的时候,按照 CSS 的”层叠”（cascade）规则,会读取优先级最高的声明。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123; <span class="attribute">--color</span>: blue; &#125;</span><br><span class="line">    <span class="selector-tag">div</span> &#123; <span class="attribute">--color</span>: green; &#125;</span><br><span class="line">    <span class="selector-id">#alert</span> &#123; <span class="attribute">--color</span>: red; &#125;</span><br><span class="line">    * &#123; <span class="attribute">color</span>: <span class="built_in">var</span>(--color); &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>蓝色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>绿色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"alert"</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>浏览器兼容性:<br><img src="http://img.blog.csdn.net/20170618015948328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYyNzY1Mjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p></li></ol><h2 id="Feature-Queries（特征查询）"><a href="#Feature-Queries（特征查询）" class="headerlink" title="Feature Queries（特征查询）"></a>Feature Queries（特征查询）</h2><p>&emsp;&emsp;多年以来,许多前端开发人员都是使用<a href="https://modernizr.com/" target="_blank" rel="noopener">Modernizr</a>这个js脚本库来实现浏览器的特征查询,让我们知道浏览器浏览器所提供的功能,以此针对性的实现某些功能或者特性.使高级浏览器有着更酷炫的效果,也使低级浏览器可以完成基本的功能.从而来提升用户体验.</p><p>&emsp;&emsp;但是Modernizr并不是完美的无懈可击的,他也有着自己的缺陷.其中最重要的一条就是执行效率的问题.Modernizr需要JavaScript.虽然其脚本可能很小,但是使用Modernizr构建的CSS需要在应用CSS之前下载,执行和完成JavaScript文件.而涉及JavaScript操作总是要比仅使用CSS慢的.</p><p>&emsp;&emsp;所以,由此.Feature Queries（特征查询）就应运而生.因为他是被CSS原生支持的.所以使用起来,更快、更强大、更简单.</p><h3 id="什么是Feature-Queries"><a href="#什么是Feature-Queries" class="headerlink" title="什么是Feature Queries?"></a>什么是Feature Queries?</h3><p>&emsp;&emsp;Feature Queries(特征查询)是一种由CSS原生支持提供的一种浏览器特征检测方法.其查询会分析浏览器是否正确地实现了个你所查询的CSS属性,并由此来决定是否应用一个CSS代码块.</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">supports</span> (supports_condition) &#123;</span><br><span class="line">  <span class="comment">/* specific rules */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@supports规则,在后面跟上你要查询的表达式.当表达式的结果返回true时,执行代码块中的代码.此外在要查询的表达式可以使用操作符,以此来实现更复杂的逻辑.同时,也可以使用小括号<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* not操作符</span><br><span class="line">&gt; not操作符可以放在任何表达式的前面来产生一个新的表达式,新的表达式为原表达式的值的否定.如果transform-origin的实现语法不认为10em 10em 10em是有效的.则下面的表达式会返回true.</span><br><span class="line"></span><br><span class="line">```CSS</span><br><span class="line">not( transform-origin: 10em 10em 10em )</span><br></pre></td></tr></table></figure></p><p><strong><em>注意</em></strong> : 如果not操作符位于表达式的最外层,则没有必要使用小括号将它括起来.但如果要将该表达式与其他表达式连接起来使用,比如and和or,则需要外面的小括号.</p><ul><li>and操作符</li></ul><blockquote><p>and操作符用来将两个原始的表达式做逻辑与后生成一个新的表达式, 如果两个原始表达式的值都为真,则生成的表达式也为真.在下例中,当且仅当两个原始表达式同时为真时,整个表达式才为真:</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="selector-tag">display</span>: <span class="selector-tag">table-cell</span>) <span class="selector-tag">and</span> (<span class="selector-tag">display</span>: <span class="selector-tag">list-item</span>)</span><br></pre></td></tr></table></figure><ul><li>or操作符</li></ul><blockquote><p>or操作符用来将两个原始的表达式做逻辑或后生成一个新的表达式, 如果两个原始表达式的值有一个为真或者都为真,则生成的表达式也为真.在下例中,当两个原始表达式中至少有一个为真时,整个表达式才为真:</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( <span class="selector-tag">transform-style</span>: <span class="selector-tag">preserve</span> ) <span class="selector-tag">or</span> ( <span class="selector-tag">-moz-transform-style</span>: <span class="selector-tag">preserve</span> )</span><br></pre></td></tr></table></figure><p><strong><em>注意</em></strong>: 在使用and和or操作符时,如果是为了定义多个表达式的执行顺序,则必须使用小括号.如果不这样做的话,该条件就是无效的,会导致整个表达式规则失效.</p><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性:"></a>浏览器兼容性:</h3><p><img src="http://img.blog.csdn.net/20170618020032948?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYyNzY1Mjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="Grid-Layout（栅格布局）"><a href="#Grid-Layout（栅格布局）" class="headerlink" title="Grid Layout（栅格布局）"></a>Grid Layout（栅格布局）</h2><p>&emsp;&emsp;如果你了解Bootstrap这个经典的前端响应式框架.那么就会知道其中的栅格布局.在Bootstrap中可以将页面最多分割为12列的栅格.以此来实现在不同尺寸设备中的响应式.</p><h3 id="什么是栅格布局"><a href="#什么是栅格布局" class="headerlink" title="什么是栅格布局:"></a>什么是栅格布局:</h3><blockquote><p>&emsp;&emsp;在一个有限的、固定的平面上，用水平线和垂直线（虚拟的线，“参考线”），将平面划分成有规律的一系列“格子”（虚拟的格子），并依托这些格子、或以格子的边线为基准线，来进行有规律的版面布局。<br>&emsp;&emsp;栅格化设计 就是把网页的宽度分成固定的相同宽度，然后列出各种组合的可能，以方便在进行页面呈现的时候能够快速的进行布局，通常分成12等分或者24等分<br>&emsp;&emsp;以规则的网格阵列来指导和规范网页中的版面布局以及信息分布。</p></blockquote><p>&emsp;&emsp;简单点说,栅格布局,就是为了保证网页的统一性.使用栅格布局可以不考虑某个元素和其他元素的宽度,只需要考虑一个页面中有多少列栅格即可.</p><p>而在页面中,要实现栅格化的布局,方式有很多.如:</p><ul><li>使用float加上相应的计算规则来实现栅格化布局.</li><li>使用flexBox弹性盒子,为子元素设置<figure class="highlight plain"><figcaption><span>1 auto```来实现栅格化布局.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 使用第三方库如:[Bootstrap](http://getbootstrap.com/)和[Foundation](http://foundation.zurb.com/)这类框架来实现栅格化布局.</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;然而,上述所示的几种方式虽然都可以实现栅格化的布局,但是却也都有着各自的缺点:</span><br><span class="line">* 使用float来实现栅格化布局需要在CSS中进行大量的计算.</span><br><span class="line">* 而flexBox是一维设计,它处理一个单独维度,一行或一列.我们不能为行和列创建一个严格的网格,这意味着如果使用flexbox网格我们还需要计算出浮动的百分比布局</span><br><span class="line">* 使用如Bootstrap和Foundation则需要导入相应的库文件,而这样就会增加网页大小.降低浏览性能.</span><br><span class="line"></span><br><span class="line">为了解决这些问题,CSS提供了原生的栅格化设计解决方```display: grid</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>CSS Grid布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。</p></blockquote><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">elementBox</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">1</span>r <span class="number">1</span>r;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">1</span>r <span class="number">1</span>r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中,使用<code>display: grid;</code>声明一个元素盒子为Grid布局.使用<code>grid-template-columns</code>和<code>grid-template-rows</code>指定Grid盒子中列的宽度和行的高度.同时也可以设置列和行的个数.这里,将Grid盒子设置为两行两列,并且宽度都是<code>1r</code>.其中<code>1r</code>为新的长度单位：fr单元,它表示在栅格容器中剩余的空间部分.</p><h3 id="Grid布局术语"><a href="#Grid布局术语" class="headerlink" title="Grid布局术语:"></a>Grid布局术语:</h3><ol><li><p>网格容器（Grid Container）:</p><blockquote><p>元素应用display:grid,它是其所有网格项的父元素.</p></blockquote></li><li><p>网格项（Grid Item）</p><blockquote><p>网格容器的子元素.</p></blockquote></li><li><p>网格线（Grid Line）</p><blockquote><p>组成网格线的分界线.它们可以是列网格线（column grid lines）,也可以是行网格线（row grid lines）并且居于行或列的任意一侧.</p></blockquote></li><li><p>网格轨道（Grid Track）</p><blockquote><p>两个相邻的网格线之间为网格轨道,你可以认为它们是网格的列或行.</p></blockquote></li><li><p>网格单元（Grid Cell）</p><blockquote><p>两个相邻的列网格线和两个相邻的行网格线组成的是网格单元，它是最小的网格单元。</p></blockquote></li><li><p>网格区（Grid Area）</p><blockquote><p>网格区是由任意数量网格单元组成.</p></blockquote></li></ol><h3 id="设置在网格容器上的属性"><a href="#设置在网格容器上的属性" class="headerlink" title="设置在网格容器上的属性"></a>设置在网格容器上的属性</h3><ul><li>display</li><li>grid-template-columns</li><li>grid-template-rows</li><li>grid-template-areas</li><li>grid-column-gap</li><li>grid-row-gap</li><li>grid-gap</li><li>justify-items</li><li>align-items</li><li>justify-content</li><li>align-content</li><li>grid-auto-columns</li><li>grid-auto-rows</li><li>grid-auto-flow</li><li>grid</li></ul><h3 id="浏览器兼容性-1"><a href="#浏览器兼容性-1" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p><img src="http://img.blog.csdn.net/20170618020104173?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYyNzY1Mjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>&emsp;&emsp;以上就是我对CSS 新特性之 Native Variables、 Feature Queries、Grid Layout的学习和理解.希望对大家有所帮助,如果文中有所不当之处,请予以斧正. 谢谢!</p><p><strong><em>参考资料</em></strong></p><ol><li><a href="http://www.ruanyifeng.com/blog/2017/05/css-variables.html" target="_blank" rel="noopener">CSS 变量教程</a></li><li><a href="http://www.jianshu.com/p/d183265a8dad" target="_blank" rel="noopener">Grid布局指南</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout" target="_blank" rel="noopener">MDN 网格布局</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports" target="_blank" rel="noopener">MDN @supports</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_variables" target="_blank" rel="noopener">MDN 使用CSS变量</a></li></ol><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 页面布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Symbol()类型的数据?</title>
      <link href="/2017/04/15/%E5%AF%B9%E4%BA%8EES6%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BSymbol()%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/04/15/%E5%AF%B9%E4%BA%8EES6%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BSymbol()%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<ol><li><h2 id="什么是Symbol-类型的数据"><a href="#什么是Symbol-类型的数据" class="headerlink" title="什么是Symbol()类型的数据?"></a>什么是Symbol()类型的数据?</h2>Symbol()是ECMAScript2015(ECMA6)中新推出的一种基本的数据类型.MDN上介绍到:</li></ol><blockquote><p> Symbol 是一种特殊的、不可变的数据类型,可以作为对象属性的标识符使用。Symbol 对象是一个 symbol primitive data type 的隐式对象包装器。symbol 数据类型是一个 primitive data type.<br>—<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">MDN</a></p></blockquote><p>简单点来说:</p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* ```Symbol()```对象是```symbol```基本类型数据的隐式对象包装器.其相当与```String()```和```string```、```Number()```和```number```、```Boole()```和```boole```.</span><br><span class="line">* ```symbol```是基本数据类型.</span><br><span class="line"></span><br><span class="line">2. ## Symbol()的基本语法和特性</span><br><span class="line">    * 创建一个Symbol类型的数据:</span><br><span class="line"></span><br><span class="line">        1. 创建局部的Symbol:</span><br><span class="line"></span><br><span class="line">        ```javascript</span><br><span class="line">        let s = Symbol();</span><br><span class="line"></span><br><span class="line">        s // Symbol()</span><br></pre></td></tr></table></figure><pre><code>2. 创建全局的Symbol:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>.for();</span><br><span class="line"></span><br><span class="line">s <span class="comment">//Symbol(undefined)</span></span><br></pre></td></tr></table></figure></code></pre><p>  <em>注意:</em> 通过Symbol函数创建Symbol数据时,不能使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Symbol的实例描述:</span><br><span class="line"></span><br><span class="line">在使用```Symbol()```函数创建Symbol实例时,可以在```Symbol()```函数中传入参数,以用做对Symbol实例的描述.</span><br><span class="line">```JavaScript</span><br><span class="line">let s1 = Symbol(&quot;这是一个Symbol实例的描述1&quot;);</span><br><span class="line">let s2 = Symbol(&quot;这是一个Symbol实例的描述2&quot;);</span><br><span class="line"></span><br><span class="line">s1 // Symbol(这是一个Symbol实例的描述1)</span><br><span class="line">s2 // Symbol(这是一个Symbol实例的描述2)</span><br></pre></td></tr></table></figure></p><p>  在上面那段代码中我们创建了两个Symbol类型的实例,如果不添加描述的话,在控制台中打印两个实例.其得到的结果将都是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Symbol类型数据的特性:</span><br><span class="line"></span><br><span class="line">    1. 每一个Symbol实例都是独一无二的.</span><br><span class="line"></span><br><span class="line">    任何情况下两个Symbol实例都不会相等,这个与JavaScript中其他的几种数据类型不同.</span><br><span class="line"></span><br><span class="line">    ```JavaScript</span><br><span class="line">    let a = Symbol();</span><br><span class="line">    let b = Symbol();</span><br><span class="line"></span><br><span class="line">    a === b // false</span><br><span class="line"></span><br><span class="line">    let s1 = Symbol(&quot;Symbol实例&quot;);</span><br><span class="line">    let s2 = Symbol(&quot;Symbol实例&quot;);</span><br><span class="line"></span><br><span class="line">    s1 //Symbol(Symbol实例)</span><br><span class="line">    s2 //Symbol(Symbol实例)</span><br><span class="line"></span><br><span class="line">    s1 === s2 // false</span><br></pre></td></tr></table></figure></p><pre><code>2. Symbol实例不能与其他类型的数据进行运算,但可以显示的转换成字符串和布尔值.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">//和字符串进行运算</span></span><br><span class="line"><span class="string">"s"</span> + a <span class="comment">//TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和数字进行运算</span></span><br><span class="line"><span class="number">1</span> + a <span class="comment">//TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和布尔值进行运算</span></span><br><span class="line"><span class="literal">false</span> + a <span class="comment">//TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和数组进行运算</span></span><br><span class="line">[] + a <span class="comment">//TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和对象进行运算</span></span><br><span class="line">(&#123;&#125;) + a <span class="comment">//TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成字符串</span></span><br><span class="line">a.toString() <span class="comment">//"Symbol()"</span></span><br><span class="line"><span class="built_in">String</span>(a) <span class="comment">//"Symbol()"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成布尔值</span></span><br><span class="line">!!a <span class="comment">//true;</span></span><br></pre></td></tr></table></figure></code></pre><ul><li><p>内置的Symbol值:</p><ol><li><p><strong>Symbol.hasInstance</strong></p><blockquote><p>对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。</p></blockquote></li><li><p><strong>Symbol.isConcatSpreadable</strong></p><blockquote><p>对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。</p></blockquote></li><li><p><strong>Symbol.species</strong></p><blockquote><p>对象的Symbol.species属性，指向当前对象的构造函数。创造实例时，默认会调用这个方法，即使用这个属性返回的函数当作构造函数，来创造新的实例对象。</p></blockquote></li><li><p><strong>Symbol.match</strong></p><blockquote><p>对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。</p></blockquote></li><li><p><strong>Symbol.replace</strong></p><blockquote><p>对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</p></blockquote></li><li><p><strong>Symbol.search</strong></p><blockquote><p>对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。</p></blockquote></li><li><p><strong>Symbol.split</strong></p><blockquote><p>对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。</p></blockquote></li><li><p><strong>Symbol.iterator</strong></p><blockquote><p>对象的Symbol.iterator属性，指向该对象的默认遍历器方法。</p></blockquote></li><li><p><strong>Symbol.toPrimitive</strong></p><blockquote><p>对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p></blockquote></li><li><p><strong>Symbol.toStringTag</strong></p><blockquote><p>对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。</p></blockquote></li><li><p><strong>Symbol.unscopables</strong></p><blockquote><p>对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。</p></blockquote></li></ol></li></ul></li></ul><ol start="3"><li><h2 id="使用Symbol实例作为对象的属性名"><a href="#使用Symbol实例作为对象的属性名" class="headerlink" title="使用Symbol实例作为对象的属性名"></a>使用Symbol实例作为对象的属性名</h2></li></ol><p>前面说到过,Symbol实例因为其不可变得特性,适合作为对象的属性名来使用.以防止属性被改写和覆盖.然而,Symbol实例怎么样来保证属性名不会被改写了.难道是,用Symbol实例定义的属性就不能修改值了吗?让我们来试试.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">obj[a] <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">obj[a] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">obj[a] <span class="comment">//20</span></span><br></pre></td></tr></table></figure><p>在上面的代码中我们可以看到,使用Symbol实例作为属性名,并不是不能修改的.在最开始我们将<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">事实上,Symbol实例的不可变更的特性,是要在两个及两个以上的作用域中才能体现出来.请看下面的代码.</span><br><span class="line"></span><br><span class="line">```JavaScript</span><br><span class="line">let a = Symbol();</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">&#123;</span><br><span class="line">    obj[a] = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    let a = Symbol();</span><br><span class="line">    obj[a] = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj //Object &#123;Symbol(): 10, Symbol(): 20&#125;</span><br><span class="line">obj[a] //10</span><br></pre></td></tr></table></figure></p><p>在上面代码中可以看到,我们在全局作用域中声明了一个Symbol <code>a</code> 实例和一个对象 <code>obj</code> ,然后在一个代码块中将<code>obj[a] = 10</code>赋值.之后在另一个代码块中再次声明一个Symbol()的实例 <code>a</code> ,并将 <code>obj[a] = 20</code><br>最后在全局下打印<code>obj[a]</code>,结果为10,并没有被改写.而打印<code>obj</code>则结果为<code>Object {Symbol(): 10, Symbol(): 20}</code>,其定义的两个属性都存在.<br>这就是Symbol实例的不可变特性,因为每一个Symbol实例都是独一无二的,所以你在另一个代码块中声明同样的一个Symbol实例的变量,也依然不会将之前的给覆盖掉.这就是使用Symbol实例作为属性名的作用.</p><p>另外,使用Symbol实例作为属性名还有着一下特性:</p><ol><li><blockquote><p>Symbol 值作为对象属性名时，不能用点运算符。</p></blockquote></li><li><blockquote><p> Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</p></blockquote></li></ol><p>以上就是我对与Symbol这个新数据类型的理解和学习,希望对大家有所帮助.同时如果文中有什么不当之处,请予以斧正,谢谢!</p><p><strong>参考资料</strong> : <a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">ECMAScript 6 入门第十章 Symbol篇</a> 作者：<a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰</a></p><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化动画之requestAnimationFrame</title>
      <link href="/2017/04/04/%E4%BC%98%E5%8C%96JS%E5%8A%A8%E7%94%BB%E4%B9%8BrequestAnimationFrame/"/>
      <url>/2017/04/04/%E4%BC%98%E5%8C%96JS%E5%8A%A8%E7%94%BB%E4%B9%8BrequestAnimationFrame/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是requestAnimationFrame"><a href="#什么是requestAnimationFrame" class="headerlink" title="什么是requestAnimationFrame"></a>什么是requestAnimationFrame</h2><p>&emsp;&emsp;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; window.requestAnimationFrame() 方法告诉浏览器您希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画。该方法将在重绘之前调用的回调作为参数。</span><br><span class="line"></span><br><span class="line">## 为什么要使用requestAnimationFrame</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;或许有人会疑问,用JS执行页面动画效果不是有```setInterval```和```setTimeout```了吗,那为什么还要使用```requestAnimationFrame```,</span><br><span class="line">它有着什么样的好处.</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;很多人都知道,由于JS的单线程特性以及使用事件队列的运行机制使得在使用```setinterval```和```setTimeout```方法来实现的JS动画其效果往往差强人意.</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;这是因为单线程的JS在每一个时间段内只能执行一个任务,如遇到多个任务同时触发,也会先只执行一个.将剩余的放入事件队列当中.等到当前任务执行完了之后,在从队列中取出下一个任务进行执行,并在执行完成之后,再取出下一个任务.如此往复,直至事件队列的任务都执行完毕.这样就导致了JS在事件队列的任务执行完之前,会造成阻塞,在这期间JS是不会区执行其他的任务请求,包括```setinterval```和```setTimeout```这两个定时器的触发.由此就导致了```setinterval```和```setTimeout```的触发执行时间无法把控,从而造成页面上的JS动画效果不理想.</span><br><span class="line"></span><br><span class="line">请看下面代码:</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;,0)</span><br><span class="line"></span><br><span class="line">console.log(2);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在上面这段代码中我们首先设定了一个定时器,并指定它在0毫秒之后触发,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;*先定义一个定时器,但不去管它的触发时间.因为当前的任务要求只是要设定一个定时器.然后执行下一个任务.```console.log```打印2.之后将当前队列中的任务执行完毕后,再去检查定时是否到达了指定的触发时间.如果达到则执行定时器中的代码由此```console.log```打印出1*</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;以上就是一个定时器的大概执行过程,在这个过程中JS永远只会在当前的事件队列里的人物执行完毕后才会去检查定时是否到达指定的触发时间.哪怕在这期间的耗时超过了定时器的指定触发时间,也不会例外.所以这就是为什么很多使用```setinterval```和```setTimeout```做的JS动画效果越往后会感觉越卡的原因所在了.而由此针对这个问题就诞生了```requestAnimationFrame```这个专门的JS动画API.</span><br><span class="line"></span><br><span class="line">## requestAnimationFrame的优势</span><br><span class="line"></span><br><span class="line">&gt; &amp;emsp;&amp;emsp;requestAnimationFrame的优势，在于充分利用显示器的刷新机制，比较节省系统资源。显示器有固定的刷新频率（60Hz或75Hz），也就是说，每秒最多只能重绘60次或75次，requestAnimationFrame的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行页面重绘。此外，使用这个API，一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力。  </span><br><span class="line">&amp;emsp;&amp;emsp;不过有一点需要注意，requestAnimationFrame是在主线程上完成。这意味着，如果主线程非常繁忙，requestAnimationFrame的动画效果会大打折扣。</span><br><span class="line"></span><br><span class="line">## requestAnimationFrame的语法</span><br><span class="line"></span><br><span class="line">&amp;esmp;&amp;esmp;requestAnimationFrame的语法的语法很简单:</span><br><span class="line"></span><br><span class="line">```JavaScript</span><br><span class="line">requestID = window.requestAnimationFrame(callback);</span><br></pre></td></tr></table></figure></p><p>只需要window对象调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面是由[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)上给出的一个例子</span><br><span class="line"></span><br><span class="line">```JavaScript</span><br><span class="line"></span><br><span class="line">window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;</span><br><span class="line"></span><br><span class="line">var start = null;</span><br><span class="line">var d = document.getElementById(&apos;SomeElementYouWantToAnimate&apos;);</span><br><span class="line">function step(timestamp) &#123; </span><br><span class="line">  if (start === null) start = timestamp;</span><br><span class="line">  var progress = timestamp - start;</span><br><span class="line">  d.style.left = Math.min(progress/10, 200) + &quot;px&quot;;</span><br><span class="line">  if (progress &lt; 2000) &#123;</span><br><span class="line">    requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(step);</span><br></pre></td></tr></table></figure></p><h2 id="requestAnimationFrame的兼容性"><a href="#requestAnimationFrame的兼容性" class="headerlink" title="requestAnimationFrame的兼容性"></a>requestAnimationFrame的兼容性</h2><p><img src="http://img.blog.csdn.net/20170705221735247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzYyNzY1Mjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="requestAnimationFrame的兼容性"></p><p><strong>参考资料 :</strong></p><ol><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">MDN - window.requestAnimationFrame</a></p></li><li><p><a href="http://javascript.ruanyifeng.com/htmlapi/requestanimationframe.html" target="_blank" rel="noopener">JavaScript 标准参考教材 - requestAnimationFrame</a></p></li></ol><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 页面动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对JavaScript中闭包的理解</title>
      <link href="/2017/03/28/%E5%AF%B9JavaScript%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2017/03/28/%E5%AF%B9JavaScript%E4%B8%AD%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>之前对于闭包这个概念的理解都是模糊的，只是单纯的知道闭包的作用：</p><ol><li><strong>可以在函数的外部访问到函数内部的局部变量。</strong></li><li><strong>让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</strong></li></ol><p>&emsp;&emsp;而这几天通过各种资料和博客的学习，自认对闭包的概念和原理有了一定的了解，所以来分享一下我的心得。如果文中有什么不当之处，请多多谅解，并给与指正。谢谢！</p><p>###什么是闭包？<br>在维基百科中的描述是：</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p></blockquote><p>上面的描述可能对于初学者来说有点晦涩。所以我们再来看看在JavaScript高级程序设计（第3版）中的描述：</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p></blockquote><p>&emsp;&emsp;综合这两个解释，我们大概的可以理解为：闭包是可以在另一个函数的外部访问到其作用域中的变量的函数。而被访问的变量可以和函数一同存在。即使另一个函数已经运行结束，导致创建变量的环境销毁，也依然会存在，直到访问变量的那个函数被销毁。就如下面代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum = sum ? sum + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = add();</span><br><span class="line"><span class="built_in">console</span>.log(a());<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(a());<span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(a());<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(a());<span class="comment">//4</span></span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line">a = add();</span><br><span class="line"><span class="built_in">console</span>.log(a());<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么为什么会这样了？我们都知道在javaScriptS中，在函数的外部是不能访问函数内部的变量的。并且随着函数运行的结束，函数内部定义的变量也会被JavaScript的自动回收机制回收掉，并不会一直存在。那为什么闭包可以不受限制了，下面我们就来详细讨论下这个问题。</p><p>&emsp;&emsp;想要理解JavaScript中闭包的概念。首先我们先要了解JavaScript中的作用域链。</p><blockquote><p>&emsp;&emsp;当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p></blockquote><p>&emsp;&emsp;上面的一段是JavaScript高级程序设计（第3版）对作用域链的描述。简单来说就是在函数中所能访问的变量按照层级关系所组成的一条有着先后顺序的链子。所以每个函数最先能访问的变量（也就是在这条链子上最先能接触到的）是当前函数的活动对象（就是在函数当中定义或重新赋值的变量），其次下一个能访问的变量就是当前的函数所在的包含环境。（其包含环境一般是指外部函数或全局执行环境。但在ES6当中块级代码语句也有可能生成包含环境。）然后是下下个包含环境。这样一层层的找下去，直到找到全局执行环境为止。</p><p>&emsp;&emsp;所以这样我们就知道，能够访问一个函数A内部变量的除了这个函数A本身之外，其函数A所生成的包含环境中所在的函数B也可以访问。而知道了这一点我们就可以很容易猜到闭包的原理。那就是既然函数A内部所在的其它函数B可以访问到当前函数A的内部变量，那么如果我们将其内部所在的其它函数B作为返回值将其返回，并在函数A的外部用一个变量C来接收到这个返回值。那么这样，在函数A外部操作这个变量C时，实际上就是在操作函数A的返回值，也就是函数A所生成的包含环境中所在的内部函数B。而这个内部函数B是有权访问到函数A的内部变量的，所以在函数A外部的变量也就可以访问到函数A内部的变量。</p><p>&emsp;&emsp;这样就实现了在函数外部访问到函数内部变量的操作。</p><p>&emsp;&emsp;同时因为闭包的这一作用，也就有了闭包的另一个作用：<strong><em>被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</em></strong>也就是说被函数A外部的变量C所访问到的函数A的内部变量，将会和变量C一同存在。即使函数A已经运行完毕，其内部变量也不会被JavaScript的自动回收机制回收掉。</p><p>&emsp;&emsp;因为此时，函数A的内部函数B依然在访问函数A的内部变量。而内部函数B被返回给了函数A外部的变量C。此时变量C就代表了内部函数B，而又因为变量C位于函数A的外部。所以函数A的结束运行，并不能影响到变量C的值，所以即使函数A结束运行。但变量C的值依然存在，而变量C的值函数A的内部函数B。而函数B是有权访问函数A的内部变量的，所以就算函数A结束运行，按照逻辑变量C依然要可以访问到函数A的内部变量。而这就与我们说知道的变量生命周期产生了冲突。</p><p>&emsp;&emsp;然而只要了解了JavaScript的自动回收机制，就会发现这一切并不意外。</p><blockquote><p>JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p></blockquote><p>&emsp;&emsp;上面一段是JavaScript高级程序设计（第3版）中对于avaScript的自动回收机制的描述。其中有这么一段<strong>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们</strong>。所以当函数A的内部变量被内部函数B访问时，此时函数A的内部变量就进入了函数B的环境中。而前面就说到，函数A的结束执行并不会影响到函数A外部的变量C，也就是内部函数B。所以内部函数B的环境会一直存在，直到变量C被注销。因而函数A的内部变量也会一直存在到变量C的注销为止。</p><p>以上就是我个人对于闭包的理解。希望对大家有所帮助！</p><p>###最后要注意：</p><ul><li>闭包只能取得包含函数中任何变量的最后一个值。因为别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。</li><li>在确定绝对需要的地方才使用闭包。因为闭包到制变量不会被自动回收这一特性，可能会导致内存泄漏。</li></ul><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node那些事之认识node</title>
      <link href="/2017/03/18/Node%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E8%AE%A4%E8%AF%86node/"/>
      <url>/2017/03/18/Node%E9%82%A3%E4%BA%9B%E4%BA%8B%E4%B9%8B%E8%AE%A4%E8%AF%86node/</url>
      
        <content type="html"><![CDATA[<h2 id="Node-JSd的起源"><a href="#Node-JSd的起源" class="headerlink" title="Node.JSd的起源"></a>Node.JSd的起源</h2><p>  <a href="http://blog.csdn.net/u012028371/article/details/54884056" target="_blank" rel="noopener">nodejs的历史由来</a></p><p>  &emsp;&emsp;Node的创造者Ryan Dahl之前主要是做高性能服务器维护的.结合他的工作经验,他发现一个高性能的服务器主要有几个要点: <strong>事件驱动</strong> 、<strong>非阻塞I/O</strong>.<br>  &emsp;&emsp;而Ryan Dahl基于这几个要点,分析了<code>C</code>,<code>C++</code>,<code>java</code>,<code>C#</code>,<code>JavaScript</code>几门语言.最终选择语言为<code>JavaScript</code>,解析器为V8引擎.</p><h2 id="什么是Node-JS"><a href="#什么是Node-JS" class="headerlink" title="什么是Node.JS?"></a>什么是Node.JS?</h2><ul><li><p>Node.JS是一个基于Chrome的V8引擎的JavaScript运行环境</p><ul><li>我们使用JS写的Node代码,就本质而言,只是单纯的字符串而已.不仅是Node,其他语言也是这样.计算机并不能直接的运行.</li><li>而如果想要执行这些代码,就需要有一个解析执行环境.就Node而言,这个环境就是Chrome的V8引擎.</li></ul></li><li><p>Node.JS使用了一个事件驱动,非阻塞式I/O的模型,使其轻量又高效</p><ul><li>事件驱动: 当触发某个指定的事件时,才会执行其指定的代码.否则永远不会执行.</li><li>非阻塞式I/O的模型: 采用非阻塞的操作,可以有效的提高代码的执行效率.</li></ul></li><li><p>Node.JS的包管理器npm,是全球最大的开源库生态系统.</p><ul><li>npm的使用流程:</li></ul><ol><li>使用<code>npm init -y</code>初始化一下把管理文件<code>package.json</code>,将来所有安装的包都会记录到<code>package.json</code>文件当中去.</li><li>使用<code>npm install [包名] --save/--save-dev</code>安装你所需要的包.其中,<code>install</code>可以简写成<code>i</code>.</li><li><code>--save</code>表示把包安装到部署依赖当中(在开发和部署上线都需要使用的包).<code>--save-dev</code>表示把包安装到开发依赖当中(只有在开发时才会使用到的包).</li><li><code>--save</code>可以简写成<code>-S</code>.<code>--save-dev</code>可以简写成<code>-D</code>.</li><li>使用<code>npm uninstall [包名] --save/--save-dev</code>或<code>npm remove [包名] --save/--save-dev</code>即可卸载指定的包.</li><li>使用<code>npm i [包名] -g</code>即可将包安装到全局环境中.这样在任何地方都可以使用.</li></ol></li><li><p>NPM 和 GitHub与GIt之间的关系</p><ul><li>NPM是包管理平台(里面托管了各种各样的包).</li><li>GitHub是代码托管平台(托管了各种各样的代码创库).</li><li>GIt使用来对代码进行分支管理的.</li></ul></li><li><p>什么是Yarn</p><ul><li>Yarn和npm的作用完全一样,都是用来管理项目中的第三方依赖包的.</li><li>Yarn是Facebook公司推出来的一套包管理工具.在使用React和ReactNative的时,默认就是用Yarn来安装其依赖包的.</li><li>Yarn会缓存曾经安装过的包,虽然npm也会缓存,但其效果不如Yarn明显.</li></ul></li><li><p>设置npm和Yarn的国内淘宝镜像<br><strong>什么是淘宝镜像:</strong> 由于npm和Yarn的服务器在国外,所以每次安装包的时候需要走国外的网络,速度很慢.因此,淘宝帮助我们在国内建立了镜像.来帮助我们提高安装包的速度.</p><ol><li>配置npm的国内淘宝镜像:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure><ol start="2"><li>配置Yarn的国内淘宝镜像:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn config set registry https://registry.npm.taobao.org --global</span><br><span class="line">yarn config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure></li></ul><h2 id="Node-JS可以做哪些事"><a href="#Node-JS可以做哪些事" class="headerlink" title="Node.JS可以做哪些事:"></a>Node.JS可以做哪些事:</h2><ul><li>Node可以作为一个工具区使用,通过NPM安装需要的包,然后用Node.JS区使用它.</li><li>Node可以做服务器开发.</li><li>Node还可以操作数据库(如MongoDB)并对外提供数据接口.</li><li>Node可以做及时聊天.</li></ul><h2 id="Node中执行相关的JS代码的两种方式"><a href="#Node中执行相关的JS代码的两种方式" class="headerlink" title="Node中执行相关的JS代码的两种方式"></a>Node中执行相关的JS代码的两种方式</h2><ol><li><p>直接在命令行中输入<code>node</code>,进入Node的<code>REPL</code>运行环境:</p><ul><li>R: Read -读取用户输入的字符串.</li><li>E: Evaluate -把用户输入的字符串,当做JS代码去解析.</li><li>P: Print -打印输出Evaluate解析的结果.</li><li>L: Loop -进入下一次循环.</li></ul></li><li><p>将Node代码写入到一个JS文件中,然后通过<code>node [要执行的JS文件]</code>去运行Node代码.</p></li></ol><p><strong>总结:Node.js就是一个JavaScript的服务端运行环境(依赖Chrome的v8引擎),为JavaScript提供了服务端编程的能力</strong></p><p><strong>我的个人网址:</strong> <a href="http://www.wangyiming19950222.com" target="_blank" rel="noopener">http://www.wangyiming19950222.com</a></p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="http://www.infoq.com/cn/articles/what-is-nodejs/" target="_blank" rel="noopener">深入浅出Node.js（一）：什么是Node.js</a></li><li><a href="http://www.cnblogs.com/eric-nirnava/p/IO.html" target="_blank" rel="noopener">I/O事件概述</a></li><li><a href="http://www.cnblogs.com/lua5/archive/2011/02/01/1948760.html" target="_blank" rel="noopener">理解Node.js事件驱动编程</a></li><li><a href="http://nodejs.cn/api/documentation.html" target="_blank" rel="noopener">Node.js 中文网</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 英文官网</a></li><li><a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">Node.js 菜鸟教程</a></li><li><a href="https://cnodejs.org/" target="_blank" rel="noopener">CNode：Node.js专业中文社区</a></li><li><a href="http://download.csdn.net/download/u010733705/9555797" target="_blank" rel="noopener">深入浅出Node.js(朴灵)完整扫描版.pdf</a></li><li><a href="http://www.nowamagic.net/academy/detail/23350305" target="_blank" rel="noopener">HTTP Keep-Alive是什么？如何工作？</a></li><li><a href="http://www.nowamagic.net/librarys/veda/detail/2576" target="_blank" rel="noopener">浏览器User-agent String里的历史故事</a></li><li><a href="https://aui.github.io/art-template/docs/api.html" target="_blank" rel="noopener">art-template API</a></li><li><a href="http://www.jb51.net/article/95199.htm" target="_blank" rel="noopener">yarn与npm的命令行小结</a></li></ul><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Node那些事系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解什么是的面向对象设计</title>
      <link href="/2017/03/16/%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
      <url>/2017/03/16/%E7%90%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;我想大家都知道。现在最流行的设计模式就是面向对象，那么什么是面向对象呢？<br>&emsp;&emsp;首先我们来看下官方的定义。在维基百科上说：</p><blockquote><p>&emsp;&emsp;面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象  </p></blockquote><p>&emsp;&emsp;上面是维基百科上对于面向对象的解释。这段话对于刚刚学习编程的人来说可能有点抽象，不太容易懂。至少我在第一次看到这句话时，是一脸懵逼的。下面我来说说我对面向对象的一个理解。</p><p>要理解什么是面向对象，我们就先要知道什么是面向过程。</p><p>面向过程：<strong>就是将要实现一个功能所需要的步骤一步一步的写出来出来，要做到面面俱到、有条不絮。</strong></p><p>&emsp;&emsp;例如在JavaScript如果需要在页面当中插入一个DOM元素。按照面向过程的设计方法就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(“div”);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br></pre></td></tr></table></figure><p>如果需要让这元素显示出来这需要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.style.width = “<span class="number">100</span>px”;</span><br><span class="line">div.style.height = “<span class="number">100</span>px”;</span><br><span class="line">div.style.backgroundColor = “blue”;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样就可以在页面中显示边长为100px蓝色的区块。而如果你还想再要在页面插入一个DOM元素，这就需要将上面类似的代码再写一遍。这就是面向过程的设计方式。</p><p>而面向对象：<strong>就是找到或创建一个可以实现你想要功能的对象，然后调用这个对象来实现想要的功能。</strong>就如下面：</p><ul><li>首先我们定义一个对象：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElem</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line"><span class="comment">//创建DOM对象。</span></span><br><span class="line"><span class="keyword">this</span>.DOM = <span class="built_in">document</span>.createElement(elem);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置样式</span></span><br><span class="line"><span class="keyword">this</span>.css = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (!obj.hasOwnProperty(key)) &#123;</span><br><span class="line"><span class="keyword">this</span>.DOM.style[key] = obj[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置属性</span></span><br><span class="line"><span class="keyword">this</span>.setAttributes = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">this</span>.DOM.setAttribute(key, obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到页面中</span></span><br><span class="line"><span class="keyword">this</span>.appendTo = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">node.appendChild(<span class="keyword">this</span>.DOM);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在调用这个对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要设置的样式</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="string">"width"</span> : <span class="string">"100px"</span>,</span><br><span class="line"><span class="string">"height"</span> : <span class="string">"100px"</span>,</span><br><span class="line"><span class="string">"backgroundColor"</span> : <span class="string">"blue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用创建的对象。</span></span><br><span class="line">createElem(<span class="string">"div"</span>).</span><br><span class="line">css(obj).</span><br><span class="line">appendTo(<span class="built_in">document</span>.body).</span><br><span class="line">setAttributes(&#123;<span class="string">"id"</span> : <span class="string">"main"</span>,<span class="string">"class"</span> : <span class="string">"box"</span>&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样的话同样在页面上显示出一个边长为100px 的蓝色区块。并且，如果想要再插入一个DOM元素的话。那就再调用上面的对象并传入相应的参数就可以了。所以说：<strong>面向对象就是将面向过程的代码进行封装，并将其核心的参数抽象化，使其可以复用，从而减少代码量的一个模式。</strong><br>&emsp;&emsp;最后要明确一个概念：<strong>面向对象不是面向过程的代替，而是面向过程的封装。</strong>所以不管你如何的面向对象，最终还是要靠一步一步的过程来实现你想要的功能的。</p><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在HTML5的时代,重新认识Cookie</title>
      <link href="/2017/01/16/%E5%9C%A8HTML5%E7%9A%84%E6%97%B6%E4%BB%A3,%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Cookie/"/>
      <url>/2017/01/16/%E5%9C%A8HTML5%E7%9A%84%E6%97%B6%E4%BB%A3,%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86Cookie/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;Cookie是什么?我想任何一个互联网的从业者都会很快的告诉你,它是一种浏览器本地存储的一种方式.可以将一部分资源存放在本地,已达到更好的网络体验.</p><p>&emsp;&emsp;然而随着HTML5规范的普及,我们现在似乎有了更好的解决方案.<code>LocalStorage</code>和<code>SessionStorage</code>.它们是专门为本地存储而诞生的解决方案.和Cookie相比起来.它们也似乎更加优秀:</p><ul><li>它们有着更好用的API.</li></ul><p>&emsp;&emsp;对于Cookie来说它只有一个<code>document.cookie</code>这一个API可以使用,不管是读取<code>Cookie</code>还是存储<code>Cookie</code>你都只能使用它.并且<code>Cookie</code>在存储时只能存储一段字符串.所在读取和存储时你都要另外的区封装方法已到达你想要的效果.</p><p>&emsp;&emsp;而<code>LocalStorage</code>和<code>SessionStorage</code>不一样.以<code>LocalStorage</code>为例,你存储的时候有<code>localStorage.setItem()</code>,你读取的时候有<code>localStorage.getItem()</code>,你想要删除的时候有<code>localStorage.removeItem()</code>.此外在存储时,它们事以键值对的形式存储的.所以更易于使用.</p><ul><li>更大的存储空间.</li></ul><p>&emsp;&emsp; Cookie的存储大小只有4KB,而<code>LocalStorage</code>和<code>SessionStorage</code>是5MB.</p><ul><li>永久的存储时间.</li></ul><p>&emsp;&emsp; Cookie的存储是有过期时间的,到期自动删除,而<code>LocalStorage</code>是永久存储,除非主动删除.</p><p>&emsp;&emsp;经过上述的对比,我们发现,Cookie从任何方面来说都是完败于<code>LocalStorage</code>和<code>SessionStorage</code>的,或许你会说它在兼容性方面有着优势.但是随着HTML5标准的日益普及.这一点优势也并没有想象中的那么重要.</p><p>&emsp;&emsp;那么,既然如此我们是不是就要完全的抛弃Cookie,转投<code>LocalStorage</code>和<code>SessionStorage</code>的怀抱了.其实并不是.在HTML5的时代,Cookie并不会落伍.依然会具有重要的地位.这是因为<code>Cookie</code>的本地存储功能虽然被代替了.但是他的本职工作却依然无可替代.那它的本质工作是什么了 —-<strong><em>服务器远程在浏览器端存储数据并以此跟踪和识别用户的机制。</em></strong></p><p>然我们来看看维基百科上对于Cookie的几段描述:</p><blockquote><p>&emsp;&emsp;Cookie（复数形态Cookies），中文名称为“小型文本文件”或“小甜饼”[1]，指某些网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。定义于RFC2109。是网景公司的前雇员卢·蒙特利在1993年3月的发明[2]。</p></blockquote><blockquote><p>&emsp;&emsp;因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么。 所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。<br>&emsp;&emsp;在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。<br>&emsp;&emsp;Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，（如果该Cookie尚未到期）浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。</p></blockquote><p>&emsp;&emsp;从上面维基百科上对<code>Cookie</code>描述我们就可以看出,Cookie诞生的原因就是解决辨别用户身份的问题.而本地存储只是实现的一个手段而已.并不是它的主要目的.只是因为,在当时除了<code>Cookie</code>之外并没有一套有效的解决本地存储的一个方案.所以<code>Cookie</code>就被拿来借用.而借用的时间一长,许多人就以为<code>Cookie</code>就是为了实现本地存储的.反而将它的本职功能给忘记了.</p><p>&emsp;&emsp;那么,获取有人会问了,<code>LocalStorage</code>和<code>SessionStorage</code>既然代替了<code>Cookie</code>的本地存储功能,那么是否能将<code>Cookie</code>的验证功能也一起代替了了.对此,我可以很绝对的告诉你这是不行的.因为服务端可以通过<code>Cookie</code>来验证用户,因为浏览器在每次请求的时候都会带上<code>Cookie</code>中的信息,这对于最多只能存储4KB大小的<code>Cookie</code>来说.这是可以的.但对于有着5MB大小的<code>LocalStorage</code>和<code>SessionStorage</code>来说是不可想象的.此外,对于<code>Cookie</code>服务端可以远程给浏览器端设置,而<code>LocalStorage</code>和<code>SessionStorage</code>.所以,基于以上两点,使用<code>LocalStorage</code>和<code>SessionStorage</code>完全代替<code>Cookie</code>就目前而言是不可能的.</p><p>&emsp;&emsp;当然说了这么多,<code>Cookie</code>也并不是没有缺陷.还是借用维基百科上面的资料:</p><p> <strong>Cookie的缺陷</strong></p><blockquote><ol><li>Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。</li><li>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）</li><li>Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。</li></ol></blockquote><p><strong>反对Cookies者</strong></p><blockquote><p>一些人反对Cookies在网络中的应用，他们的理由如下：</p></blockquote><blockquote><ol><li>识别不精确</li><li>识别有时候会发生错误</li><li>隐私，安全和广告</li></ol></blockquote><blockquote><p>&emsp;&emsp;Cookies在某种程度上说已经严重危及用户的隐私和安全。其中的一种方法是：一些公司的高层人员为了某种目的（譬如市场调研）而访问了从未去过的网站（通过搜索引擎查到的），而这些网站包含了一种叫做网页臭虫的图片，该图片透明，且只有一个像素大小（以便隐藏），它们的作用是将所有访问过此页面的计算机写入Cookie。而后，电子商务网站将读取这些Cookie信息，并寻找写入这些Cookie的网站，随即发送包含了针对这个网站的相关产品广告的垃圾邮件给这些高级人员。</p></blockquote><p><strong>偷窃Cookies和脚本攻击</strong></p><blockquote><p>&emsp;&emsp;虽然Cookies没有中电脑病毒那么危险，但它仍包含了一些敏感消息：用户名，电脑名，使用的浏览器和曾经访问的网站。用户不希望这些内容泄漏出去，尤其是当其中还包含有私人信息的时候。<br>&emsp;&emsp;这并非危言耸听，跨站点脚本（Cross site scripting）可以达到此目的。在受到跨站点脚本攻击时，Cookie盗贼和Cookie毒药将窃取内容。一旦Cookie落入攻击者手中，它将会重现其价值。<br>&emsp;&emsp;Cookie盗贼：搜集用户Cookie并发给攻击者的黑客。攻击者将利用Cookie消息通过合法手段进入用户帐户。<br>&emsp;&emsp;Cookie投毒：一般认为，Cookie在储存和传回服务器期间没有被修改过，而攻击者会在Cookie送回服务器之前对其进行修改，达到自己的目的。例如，在一个购物网站的Cookie中包含了顾客应付的款项，攻击者将该值改小，达到少付款的目的。这就是Cookie投毒。</p></blockquote><p><strong>Cookies的替代品</strong></p><blockquote><p>鉴于Cookie的局限和反对者的声音，有如下一些替代方法：</p><ol><li>Brownie方案，是一项开放源代码工程，由SourceForge发起。Brownie曾被用以共享在不同域中的接入，而Cookies则被构想成单一域中的接入。这项方案已经停止开发。</li><li>P3P，用以让用户获得更多控制个人隐私权利的协议。在浏览网站时，它类似于Cookie。</li><li>在与服务器传输数据时，通过在地址后面添加唯一查询串，让服务器识别是否合法用户，也可以避免使用Cookie。</li></ol></blockquote><p><strong>我的个人网址:</strong> <a href="https://wangyiming.info/">https://wangyiming.info/</a></p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> Cookie </tag>
            
            <tag> 本地储存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
